<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Playable Ad - Merge TD (Endless Version 3)</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin:0; background:#000; font-family: 'Poppins', Arial, sans-serif; }
        #game { margin:0 auto; display:block; }
    </style>
</head>
<body>
    <div id="game"></div>

<script>
/* =========================
    CONFIG / CONSTANTS
   ========================= */
const WIDTH = 648; const HEIGHT = 1080;
const GRID_COLS = 4; const GRID_ROWS = 5;
const CELL_SIZE = 110;
const GRID_W = GRID_COLS * CELL_SIZE; const GRID_H = GRID_ROWS * CELL_SIZE;
const GRID_X = (WIDTH - GRID_W) / 2;
const GRID_Y = 240;
const TILE_PADDING = 10;
const TOWER_TYPES = ['fire','ice','lightning','poison','arrow','mana'];
const TOWER_CONFIG = {
    fire:      { color: 0xff6a00, baseDmg: 15, specialChance: 0.2, lv5Chance: 0.15 },
    ice:       { color: 0x66ccff, baseDmg: 8,  specialChance: 0.25, lv5Chance: 0.30 },
    lightning: { color: 0xffff66, baseDmg: 10, specialChance: 0.25, lv5Chance: 0.20 },
    poison:    { color: 0x8fce00, baseDmg: 6,  specialChance: 0.3,  lv5Chance: 0.25 },
    arrow:     { color: 0xffffff, baseDmg: 12, specialChance: 0.25, lv5Chance: 0.15 },
    mana:      { color: 0x9966ff, baseDmg: 8,  specialChance: 0.0,  lv5Chance: 1.0 }
};

const ENEMY_BASE_HP = 80;
const ENEMY_BASE_SPEED = 120;
const ENEMY_SPAWN_INTERVAL = 450;
const BOSS_SPAWN_TIME = 120;
const BOSS_BASE_HP = 7500;
const BOSS_TYPES = ['spawner', 'warlock', 'teleporter'];
const BOSS_CONFIG = {
    spawner: {
        name: 'SPAWNER',
        color: 0x00ff00,
        summonInterval: 8000,
        summonCount: 3,
        description: 'It summons 3 minions every 3 seconds!'
    },
    warlock: {
        name: 'WARLOCK',
        color: 0xff6600,
        meteorInterval: 15000,
        description: 'It destroys towers! Kill ASAP!'
    },
    teleporter: {
        name: 'TELEPORTER',
        color: 0x00aaff,
        dashInterval: 15000,
        dashDistance: 300,
        description: 'It dashes forward! Very fast!'
    }
};

const MEDIUM_ENEMY_HP = 250; const MEDIUM_ENEMY_SPEED = 100; const MEDIUM_MANA_REWARD = 25;
const SPEEDY_ENEMY_HP = 50; const SPEEDY_ENEMY_SPEED = 220;
const MANA_ENEMY_HP = 120; const MANA_ENEMY_REWARD = 75;

const MANA_REGEN_RATE = 12;
const MANA_PER_KILL = 12;
const BASE_SUMMON_COST = 10;
const ULTIMATE_COOLDOWN = 30000;
const ULTIMATE_EXPLOSION_DMG = 80;
const ULTIMATE_EXPLOSION_RADIUS = 55;
const ULTIMATE_FIRE_ZONE_DURATION = 3000;
const ULTIMATE_FIRE_DMG = 15;
const PROJECTILE_SPEED = 350;

const MANA_TOWER_PASSIVE_GEN = { 5: 5, 6: 8, 7: 12, 8: 18 };

function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

/* =========================
    CLASS: TutorialManager
   ========================= */
class TutorialManager {
    constructor(gameScene, uiScene) {
        this.gameScene = gameScene; this.uiScene = uiScene; this.currentState = 'IDLE';
        this.indicator = null; this.instructionGroup = this.uiScene.add.group();
    }
    start() {
        this.currentState = 'SUMMON'; this.gameScene.time.delayedCall(500, () => {
            this.gameScene.freezeGame(); this.showSummonInstruction();
        });
    }
    showSummonInstruction() {
        const summonBtn = this.uiScene.summonBtn;
        const targetX = summonBtn.x + summonBtn.width / 2; const targetY = summonBtn.y;
        this.createHighlight('Press SUMMON to create a Tower!', targetX, targetY, 'down');
    }
    onSummonPressed() {
        if (this.currentState !== 'SUMMON') return; this.clearInstructions(); this.currentState = 'LEGEND';
        this.gameScene.time.delayedCall(500, () => this.showLegendInstruction());
    }
    showLegendInstruction() {
        const legendY = HEIGHT - 220;
        this.createHighlight('These are the different Tower types!', WIDTH / 2, legendY - 60, 'up', 500, 120);
        this.uiScene.input.once('pointerdown', () => {
            if (this.currentState !== 'LEGEND') return;
            this.clearInstructions();
            this.gameScene.unfreezeGame();
            this.gameScene.startNextWave();
            this.currentState = 'MERGE';
            this.startMergeIndicator();
        });
    }
    startMergeIndicator() {
        if (this.currentState !== 'MERGE') return;
        this.indicator = this.gameScene.time.addEvent({ delay: 500, callback: this.checkForMergeableTowers, callbackScope: this, loop: true });
    }
    checkForMergeableTowers() {
        const towers = this.gameScene.towers; const towerMap = new Map();
        for (const tower of towers) {
            const key = `${tower.type}_${tower.level}`;
            if (towerMap.has(key)) {
                if(this.indicator) this.indicator.remove(); this.indicator = null;
                this.gameScene.freezeGame(); this.showMergeInstruction(); return;
            }
            towerMap.set(key, tower);
        }
    }
    showMergeInstruction() {
        this.createHighlight('Drag and MERGE identical Towers\nto upgrade them!', WIDTH / 2, GRID_Y + GRID_H / 2, 'none');
         this.uiScene.input.once('pointerdown', () => {
             if (this.currentState !== 'MERGE') return;
             this.clearInstructions(); this.gameScene.unfreezeGame(); this.currentState = 'ULTIMATE';
         });
    }
    checkUltimate(gameTime) {
        if (this.currentState === 'ULTIMATE' && gameTime > 10000) {
            this.currentState = 'DONE'; this.gameScene.freezeGame(); this.showUltimateInstruction();
        }
    }
    showUltimateInstruction() {
        const ultBtn = this.uiScene.ultimateBtn;
        const targetY = ultBtn.y; const targetX = ultBtn.x - 140; const arrowX = ultBtn.x + ultBtn.width / 2;
        this.createHighlight('Use your ULTIMATE SKILL\nin a pinch!', targetX, targetY, 'down', 400, 120, arrowX);
         this.uiScene.input.once('pointerdown', () => { this.clearInstructions(); this.gameScene.unfreezeGame(); });
    }
    createHighlight(text, x, y, arrowDir = 'down', width = 400, height = 120, arrowX) {
        this.clearInstructions();
        const finalArrowX = arrowX || x;
        const box = this.uiScene.add.graphics({ fillStyle: { color: 0x000000, alpha: 0.8 }, lineStyle: { width: 3, color: 0xffffff, alpha: 1 } });
        box.fillRoundedRect(x - width/2, y - height - 20, width, height, 15);
        box.strokeRoundedRect(x - width/2, y - height - 20, width, height, 15);
        const instructionText = this.uiScene.add.text(x, y - height/2 - 20, text, { fontSize: '32px', color: '#ffffff', fontStyle: 'bold', align: 'center', fontFamily: "'Poppins', Arial, sans-serif", wordWrap: { width: width - 20 } }).setOrigin(0.5);
        let arrow;
        if (arrowDir === 'down') {
            arrow = this.uiScene.add.text(finalArrowX, y - 30, '▼', { fontSize: '48px', color: '#ffff00' }).setOrigin(0.5);
            this.uiScene.tweens.add({ targets: arrow, y: '+=10', duration: 500, yoyo: true, repeat: -1 });
        } else if (arrowDir === 'up') {
            arrow = this.uiScene.add.text(finalArrowX, y + 20, '▲', { fontSize: '48px', color: '#ffff00' }).setOrigin(0.5);
            this.uiScene.tweens.add({ targets: arrow, y: '-=10', duration: 500, yoyo: true, repeat: -1 });
        }
        this.instructionGroup.addMultiple([box, instructionText, arrow].filter(Boolean));
        this.instructionGroup.getChildren().forEach(c => c.setDepth(5000));
    }
    clearInstructions() { this.instructionGroup.clear(true, true); }
}

/* =========================
    SCENE: GameScene
   ========================= */
class GameScene extends Phaser.Scene {
    constructor(){ super('GameScene'); }
    preload() {
        const graphics = this.make.graphics({x: 0, y: 0, add: false});
        graphics.fillStyle(0xffffff); graphics.fillCircle(5, 5, 5);
        graphics.generateTexture('projectile_texture', 10, 10); graphics.destroy();
    }
    create(){
        this.playerHP = 10;
        this.score = 0;
        this.loop = 0;
        this.mana = 50;
        this.summonCount = 0;
        this.bossSpawned = false;
        this.boss = null;
        this.enemyHpMultiplier = 1.0;
        this.timeUntilBoss = BOSS_SPAWN_TIME;
        this.isGameOver = false;
        this.ultimateReady = true;
        this.lastUltimateTime = -ULTIMATE_COOLDOWN;
        this.fireZones = [];
        this.poisonPools = [];
        this.gameStarted = false;

        this.wave = 0;
        this.enemiesPerWave = 10;
        this.enemiesSpawnedThisWave = 0;
        this.enemiesLeftInWave = 0;
        this.waveSpawnTimer = null;

        this.isMeteorFalling = false;
        this.lastPoisonPoolTime = 0;

        this.add.rectangle(WIDTH/2, HEIGHT/2, WIDTH, HEIGHT, 0x16202a);
        this.setupGrid();
        this.setupPath();
        this.towers = [];
        this.enemies = this.add.group();
        this.setupInputHandling();
        this.floatingTextPool = this.add.group({ classType: Phaser.GameObjects.Text, maxSize: 50, runChildUpdate: false });
        this.projectilePool = this.add.group({ defaultKey: 'projectile_texture', maxSize: 100, runChildUpdate: false });
        this.physics.pause();

        this.tutorial = new TutorialManager(this, this.scene.get('UIScene'));
        this.startGame();

        this.input.keyboard.on('keydown', (event) => {
            const key = event.key.toUpperCase();
            
            if (this.isGameOver) return;
            
            switch(key) {
                case 'M':
                    this.mana += 9999;
                    this.showFloatingText(WIDTH/2, HEIGHT/2, '+9999 MANA!', '#00ff00', -20, 1000, 32);
                    break;
                case 'F': 
                    this.spawnCheatTower('fire', 10); 
                    break;
                case 'I': 
                    this.spawnCheatTower('ice', 10); 
                    break;
                case 'L': 
                    this.spawnCheatTower('lightning', 10); 
                    break;
                case 'P': 
                    this.spawnCheatTower('poison', 10); 
                    break;
                case 'A': 
                    this.spawnCheatTower('arrow', 10); 
                    break;
                case 'N': 
                    this.spawnCheatTower('mana', 10); 
                    break;
                case 'B': 
                    for(let i=0; i<15; i++) { 
                        this.spawnTestEnemy(300); 
                    } 
                    break;
            }
        });
    }
    startGame() {
        this.physics.resume();
        this.towerAttackTimer = this.time.addEvent({ delay: 200, loop: true, callback: this.updateTowerAttacks, callbackScope: this });
        this.manaRegenTimer = this.time.addEvent({ delay: 1000, loop: true, callback: this.passiveManaGen, callbackScope: this });
        this.bossTimer = this.time.addEvent({ delay: 1000, callback: this.updateBossTimer, callbackScope: this, loop: true });
        this.bossAbilityTimer = this.time.addEvent({ delay: 500, callback: this.updateBossAbilities, callbackScope: this, loop: true }); // NEW
        this.enemyScalingTimer = this.time.addEvent({ delay: 10000, callback: this.scaleEnemyHp, callbackScope: this, loop: true });
        this.gameStarted = true;
        this.tutorial.start();
    }
    startNextWave() {
        if (this.isGameOver || this.bossSpawned) return;
        this.wave++;
        this.enemiesPerWave = 10 + this.wave;
        this.enemiesSpawnedThisWave = 0;
        this.enemiesLeftInWave = this.enemiesPerWave;

        this.waveSpawnTimer = this.time.addEvent({
            delay: ENEMY_SPAWN_INTERVAL,
            callback: () => {
                if (this.enemiesSpawnedThisWave < this.enemiesPerWave) {
                    this.spawnEnemyForWave();
                    this.enemiesSpawnedThisWave++;
                } else {
                    this.waveSpawnTimer.remove();
                }
            },
            callbackScope: this,
            loop: true
        });
    }

    spawnEnemyForWave() {
        let enemyTypeChance = Math.random();
        if (this.wave > 10 && this.loop > 0 && enemyTypeChance < 0.15) {
            this.spawnMediumEnemy();
        } else if (this.wave > 8 && enemyTypeChance < 0.25) {
            this.spawnManaEnemy();
        } else if (this.wave > 5 && enemyTypeChance < 0.40) {
            this.spawnSpeedyEnemy();
        } else {
            this.spawnEnemy();
        }
    }

    passiveManaGen(){
        this.mana += MANA_REGEN_RATE;
        this.towers.forEach(tower => {
            if (tower.type === 'mana' && tower.level >= 5) {
                const manaPerSec = MANA_TOWER_PASSIVE_GEN[tower.level] || MANA_TOWER_PASSIVE_GEN[8];
                this.mana += manaPerSec;
                this.showFloatingText(tower.x, tower.y - 40, `+${manaPerSec}`, '#9966ff', -20, 600, 18);
            }
        });
    }
    freezeGame(pauseTimers = true) {
        this.physics.pause(); this.tweens.pauseAll();
        if (pauseTimers) {
            if (this.waveSpawnTimer) this.waveSpawnTimer.paused = true;
            if (this.towerAttackTimer) this.towerAttackTimer.paused = true;
            if (this.manaRegenTimer) this.manaRegenTimer.paused = true;
            if (this.bossTimer) this.bossTimer.paused = true;
            if (this.enemyScalingTimer) this.enemyScalingTimer.paused = true;
        }
    }
    unfreezeGame(resumeTimers = true) {
        this.physics.resume(); this.tweens.resumeAll();
         if (resumeTimers) {
            if (this.waveSpawnTimer) this.waveSpawnTimer.paused = false;
            if (this.towerAttackTimer) this.towerAttackTimer.paused = false;
            if (this.manaRegenTimer) this.manaRegenTimer.paused = false;
            if (this.bossTimer) this.bossTimer.paused = false;
            if (this.enemyScalingTimer) this.enemyScalingTimer.paused = false;
         }
    }
    scaleEnemyHp() {
        if (this.isGameOver) return;
        this.enemyHpMultiplier += 0.08;
    }
    updateBossTimer() {
        if (this.isGameOver || this.bossSpawned) return;
        this.timeUntilBoss--;
        if (this.timeUntilBoss <= 0) {
            this.spawnBoss();
            this.timeUntilBoss = 0;
            if (this.waveSpawnTimer) this.waveSpawnTimer.remove();
        }
    }

    updateBossAbilities() {
        if (!this.boss || this.boss.isDead) return;
        
        const now = this.time.now;
        const bossType = this.boss.bossType;
        
        if (bossType === 'spawner') {
            if (now - this.boss.lastSummonTime > BOSS_CONFIG.spawner.summonInterval) {
                this.boss.lastSummonTime = now;
                this.bossSummonMinions();
            }
        } else if (bossType === 'warlock') {
            if (now - this.boss.lastMeteorTime > BOSS_CONFIG.warlock.meteorInterval) {
                this.boss.lastMeteorTime = now;
                this.bossCastMeteor();
            }
        } else if (bossType === 'teleporter') {
            if (now - this.boss.lastDashTime > BOSS_CONFIG.teleporter.dashInterval) {
                this.boss.lastDashTime = now;
                this.bossDash();
            }
        }
    }

    bossSummonMinions() {
        if (!this.boss || this.boss.isDead) return;
        
        for (let i = 0; i < BOSS_CONFIG.spawner.summonCount; i++) {
            this.time.delayedCall(i * 300, () => {
                if (this.boss && !this.boss.isDead) {
                    const minion = this.add.rectangle(this.boss.x, this.boss.y, 25, 30, 0x00dd00).setOrigin(0.5).setStrokeStyle(2, 0xffffff);
                    // Buff minion HP and speed to match scaling enemies
                    minion.hp = (150 + Math.floor(this.score * 0.08)) * this.enemyHpMultiplier;
                    minion.maxHp = minion.hp;
                    minion.speed = ENEMY_BASE_SPEED * 1.5;
                    minion.isDead = false;
                    minion.progress = this.boss.progress;
                    minion.pathSegment = this.boss.pathSegment;
                    minion.isBossMinion = true;
                    minion.hpText = this.add.text(minion.x, minion.y - 20, `${Math.round(minion.hp)}`, { 
                        fontSize: '12px', color: '#ffffff', fontStyle: 'bold', 
                        stroke: '#000', strokeThickness: 3, fontFamily: "'Poppins', Arial, sans-serif" 
                    }).setOrigin(0.5).setDepth(150);
                    
                    this.enemies.add(minion);
                    this.moveEnemyToNextSegment(minion);
                }
            });
        }
        
        this.showFloatingText(this.boss.x, this.boss.y, '⚔ SUMMON!', '#00ff00', -40, 800, 24);
    }


    bossCastMeteor() {
        if (!this.boss || this.boss.isDead || this.towers.length === 0) return;
        
        const randomTower = randChoice(this.towers);
        const targetX = randomTower.x;
        const targetY = randomTower.y;
        
        this.showFloatingText(this.boss.x, this.boss.y, '💥 METEOR!', '#ff6600', -40, 800, 24);
        
        const meteor = this.add.circle(targetX, targetY - 300, 25, 0xff6600).setDepth(180);
        this.tweens.add({
            targets: meteor,
            y: targetY,
            duration: 600,
            ease: 'Cubic.easeIn',
            onComplete: () => {
                this.cameras.main.shake(150, 0.01);
                const explosionFx = this.add.circle(targetX, targetY, 10, 0xffdd00, 0.9).setDepth(180);
                this.tweens.add({ 
                    targets: explosionFx, 
                    radius: 100, 
                    alpha: 0, 
                    duration: 300, 
                    ease: 'Quad.easeOut', 
                    onComplete: () => explosionFx.destroy() 
                });
                
                // Damage the tower
                if (randomTower.level > 1) {
                    randomTower.level--;
                    randomTower.label.setText(`L${randomTower.level}`);
                    this.updateTowerStats(randomTower);
                    this.showFloatingText(targetX, targetY, 'DAMAGED!', '#ff0000', -30, 800, 20);
                } else {
                    // Destroy level 1 tower
                    this.destroyTower(randomTower);
                    this.showFloatingText(targetX, targetY, 'DESTROYED!', '#ff0000', -30, 800, 20);
                }
                
                meteor.destroy();
            }
        });
    }

    bossDash() {
        if (!this.boss || this.boss.isDead || this.boss.isDashing) return;
        
        this.boss.isDashing = true;
        
        // Get next path point based on current segment
        let nextSegment = this.boss.pathSegment + 1;
        if (nextSegment >= this.pathPoints.length - 1) {
            nextSegment = this.pathPoints.length - 1;
        }
        
        const nextPoint = this.pathPoints[nextSegment];
        const dashX = nextPoint.x;
        const dashY = nextPoint.y;
        
        this.showFloatingText(this.boss.x, this.boss.y, '⚡ DASH!', '#00aaff', -40, 800, 24);
        
        // Kill existing movement tweens
        this.tweens.getTweensOf(this.boss).forEach(t => {
            if (t.isPlaying() && (t.data.some(d => d.key === 'x') || t.data.some(d => d.key === 'y'))) {
                t.stop();
            }
        });
        
        // Dash forward
        this.tweens.add({
            targets: this.boss,
            x: dashX,
            y: dashY,
            duration: 500,
            ease: 'Quad.easeInOut',
            onComplete: () => {
                if (!this.boss || this.boss.isDead) return;
                this.boss.isDashing = false;
                // Continue path movement
                this.boss.pathSegment = nextSegment;
                this.moveEnemyToNextSegment(this.boss);
            }
        });
    }

    spawnBoss() {
        this.bossSpawned = true;
        this.enemyScalingTimer.paused = true;
        
        // Randomly select a boss type
        const bossType = randChoice(BOSS_TYPES);
        const startPoint = this.pathPoints[0];
        
        const boss = this.add.rectangle(startPoint.x, startPoint.y, 80, 90, BOSS_CONFIG[bossType].color).setOrigin(0.5).setStrokeStyle(4, 0xffffff);
        boss.hp = BOSS_BASE_HP * (1 + this.loop * 0.5);
        boss.maxHp = boss.hp;
        boss.speed = ENEMY_BASE_SPEED * 0.4;
        boss.isDead = false;
        boss.progress = 0;
        boss.isBoss = true;
        boss.bossType = bossType;
        boss.originalFillColor = boss.fillColor;
        
        boss.hpText = this.add.text(boss.x, boss.y - 60, `${Math.round(boss.hp)}`, { 
            fontSize: '28px', color: '#ffffff', fontStyle: 'bold', 
            stroke: '#000', strokeThickness: 5, fontFamily: "'Poppins', Arial, sans-serif" 
        }).setOrigin(0.5).setDepth(150);
        
        // Add boss type label below name
        boss.typeLabel = this.add.text(boss.x, boss.y, BOSS_CONFIG[bossType].name, { 
            fontSize: '14px', color: BOSS_CONFIG[bossType].color, fontStyle: 'bold',
            stroke: '#000', strokeThickness: 3, fontFamily: "'Poppins', Arial, sans-serif" 
        }).setOrigin(0.5).setDepth(150);
        
        // Initialize boss-specific timers - set to negative so ability triggers after 1 sec delay
        if (bossType === 'spawner') {
            boss.lastSummonTime = -2500; // Will trigger 1 sec after spawn (3000ms - 2500ms offset)
        } else if (bossType === 'warlock') {
            boss.lastMeteorTime = -14000; // Will trigger 1 sec after spawn (15000ms - 14000ms offset)
        } else if (bossType === 'teleporter') {
            boss.lastDashTime = -14000; // Will trigger 1 sec after spawn (15000ms - 14000ms offset)
            boss.isDashing = false;
        }
        
        this.enemies.add(boss);
        this.moveEnemyAlongPath(boss);
        this.boss = boss;
        
        // Announce boss type in UIScene
        const uiScene = this.scene.get('UIScene');
        uiScene.showBossAnnouncement(BOSS_CONFIG[bossType].name, BOSS_CONFIG[bossType].description, BOSS_CONFIG[bossType].color);
    }

    killEnemy(enemy){
        if(!enemy || enemy.isDead) return;
        
        // Resume any paused tweens before destroying
        this.tweens.getTweensOf(enemy).forEach(t => {
            if (t.isPaused()) t.resume();
        });
        
        this.tweens.killTweensOf(enemy);
        enemy.isDead = true;
        this.enemiesLeftInWave--;

        if (enemy.isBoss) {
            this.score += 200 * (this.loop + 1);
            this.mana += MANA_PER_KILL * 10;
            this.loop++;

            if (enemy.typeLabel) enemy.typeLabel.destroy();
            this.boss = null;
            this.bossSpawned = false;
            this.timeUntilBoss = BOSS_SPAWN_TIME;
            this.enemyScalingTimer.paused = false;
            this.startNextWave();

        } else if (enemy.isBossMinion) {
            this.score += 2;
            this.mana += MANA_PER_KILL;
        } else if (enemy.isMedium) {
            this.score += 5; this.mana += MEDIUM_MANA_REWARD;
        } else if (enemy.isSpeedy) {
            this.score += 2; this.mana += MANA_PER_KILL / 2;
        } else if (enemy.isMana) {
            this.score += 1; this.mana += MANA_ENEMY_REWARD;
        } else {
            this.score += 1; this.mana += MANA_PER_KILL;
        }
        const targetsToFade = [enemy];
        if (enemy.hpText && enemy.hpText.active) { targetsToFade.push(enemy.hpText); }
        this.tweens.add({ targets: targetsToFade, alpha: 0, scale: 0.5, duration: 200,
            onComplete: () => { if (enemy) { if (enemy.hpText) enemy.hpText.destroy(); enemy.destroy(); } }
        });

        if (this.enemiesLeftInWave <= 0 && !this.bossSpawned) {
            this.time.delayedCall(1000, this.startNextWave, [], this);
        }
    }

    update(time, delta){
        if (this.isGameOver || !this.gameStarted) return;
        this.tutorial.checkUltimate(this.time.now);
        this.enemies.getChildren().forEach(enemy => {
            if(enemy && enemy.active && !enemy.isDead && enemy.hpText && enemy.hpText.active) {
                const yOffset = enemy.isBoss ? -70 : (enemy.isMedium ? -40 : -30);
                enemy.hpText.setPosition(enemy.x, enemy.y + yOffset).setText(`${Math.round(enemy.hp)}`);
                const hpPercent = enemy.hp / enemy.maxHp;
                if (hpPercent < 0.3) enemy.hpText.setColor('#ff4444');
                else if (hpPercent < 0.6) enemy.hpText.setColor('#ffaa33');
                else enemy.hpText.setColor('#ffffff');
            }
        });
        const now = this.time.now;
        this.fireZones.forEach(zone => {
            if(!zone.visual.active) return;
            this.enemies.getChildren().forEach(enemy => {
                if (enemy && !enemy.isDead && Phaser.Math.Distance.Between(zone.x, zone.y, enemy.x, enemy.y) < zone.radius) {
                    if (!enemy.lastFireTick) enemy.lastFireTick = 0;
                    if (now - enemy.lastFireTick > 500) {
                        enemy.lastFireTick = now; enemy.hp -= zone.damage;
                        this.showFloatingText(enemy.x, enemy.y, Math.round(zone.damage), '#ff6600');
                        if (enemy.hp <= 0) this.killEnemy(enemy);
                    }
                }
            });
        });

        this.poisonPools.forEach(pool => {
            if(!pool.visual.active) return;
            this.enemies.getChildren().forEach(enemy => {
                if (enemy && !enemy.isDead && Phaser.Math.Distance.Between(pool.x, pool.y, enemy.x, enemy.y) < pool.radius) {
                    if (!enemy.lastPoisonPoolTick) enemy.lastPoisonPoolTick = 0;
                    if (now - enemy.lastPoisonPoolTick > 500) {
                        enemy.lastPoisonPoolTick = now;
                        enemy.hp -= pool.damage;
                        this.showFloatingText(enemy.x, enemy.y, Math.round(pool.damage), '#8fce00');
                        if (enemy.hp <= 0) this.killEnemy(enemy);
                    }
                }
            });
        });
    }
    onEnemyReachBase(enemy){
        if(!enemy||enemy.isDead)return;
        this.tweens.killTweensOf(enemy);
        enemy.isDead=true;
        this.enemiesLeftInWave--;

        if (enemy.isBoss) {
            this.playerHP -= 5;
        } else {
            this.playerHP--;
        }

        if (enemy.hpText) enemy.hpText.destroy();
        enemy.destroy();

        if(this.playerHP<=0)this.loseGame();

        if (this.enemiesLeftInWave <= 0 && !this.bossSpawned) {
             this.time.delayedCall(1000, this.startNextWave, [], this);
        }
    }
    endGame() {
        if (this.isGameOver) return;
        this.isGameOver = true;
        this.freezeGame();
        const uiScene = this.scene.get('UIScene');
        uiScene.showGameOver(this.score);
    }
    loseGame(){ this.endGame(); }
    setupGrid(){
        this.grid = Array(GRID_ROWS).fill(null).map(() => Array(GRID_COLS).fill(null));
        this.gridHighlights = this.add.group();
        this.add.rectangle(WIDTH/2, GRID_Y + GRID_H/2, GRID_W+20, GRID_H+20, 0x0f1720).setStrokeStyle(3, 0x2b3942);
        for(let r=0;r<GRID_ROWS;r++) { for(let c=0;c<GRID_COLS;c++) {
            this.add.rectangle(GRID_X+c*CELL_SIZE+CELL_SIZE/2, GRID_Y+r*CELL_SIZE+CELL_SIZE/2, CELL_SIZE-TILE_PADDING, CELL_SIZE-TILE_PADDING, 0x0a2533).setStrokeStyle(2, 0x24414e);
        }}
    }
    setupPath(){
        const m=40, l=GRID_X-m, r=GRID_X+GRID_W+m, t=GRID_Y-m, b=GRID_Y+GRID_H+m;
        this.pathPoints = [{x:l,y:b},{x:l,y:t},{x:r,y:t},{x:r,y:b}];
        const pathGraphics=this.add.graphics(); pathGraphics.lineStyle(5,0x555555);
        for(let i=0;i<this.pathPoints.length-1;i++) { pathGraphics.lineBetween(this.pathPoints[i].x,this.pathPoints[i].y,this.pathPoints[i+1].x,this.pathPoints[i+1].y); }
        this.totalPathLength=0; this.segmentLengths=[];
        for(let i=0;i<this.pathPoints.length-1;i++){ const d=Phaser.Math.Distance.Between(this.pathPoints[i].x,this.pathPoints[i].y,this.pathPoints[i+1].x,this.pathPoints[i+1].y); this.segmentLengths.push(d); this.totalPathLength+=d; }
    }
    setupInputHandling(){
        this.input.on('dragstart', (p, go) => {
            go.setScale(1.1).setDepth(100);
            const draggedTower = this.findTowerBySprite(go);
            if(draggedTower) {
                draggedTower.label.setDepth(101);
                this.towers.forEach(t => {
                    if (t !== draggedTower && this.canMerge(draggedTower, t)) {
                        const h = this.add.graphics({lineStyle: {width: 5, color: 0xffff00, alpha: 1}});
                        h.strokeRect(t.sprite.x - t.sprite.width/2 -3, t.sprite.y - t.sprite.height/2 -3, t.sprite.width + 6, t.sprite.height + 6).setDepth(99);
                        this.gridHighlights.add(h);
                    }
                });
            }
        });
        this.input.on('drag', (p, go, dx, dy) => {
            const draggedTower = this.findTowerBySprite(go);
            if (draggedTower) {
                draggedTower.sprite.x = dx;
                draggedTower.sprite.y = dy;
                draggedTower.label.x = dx;
                draggedTower.label.y = dy + (CELL_SIZE/2) - 24;
            }
        });
        this.input.on('dragend', (p, go) => {
            go.setScale(1.0).setDepth(1);
            const draggedTower = this.findTowerBySprite(go);
            if(draggedTower) draggedTower.label.setDepth(2);

            this.gridHighlights.clear(true, true);
            this.tryPlaceTowerFromSprite(go);
        });
    }
    doSummon(){
        if(this.isGameOver || this.time.now - this.lastSummon < 500) return;
        const cost = this.getCurrentSummonCost(); if(this.mana < cost) return;
        const empties = []; for(let r=0;r<GRID_ROWS;r++) { for(let c=0;c<GRID_COLS;c++) { if(!this.grid[r][c]) empties.push({r,c}); } }
        if(empties.length === 0) return;
        this.lastSummon=this.time.now; this.mana-=cost; this.summonCount++;
        const target=randChoice(empties); this.placeTowerAtCell(target.r, target.c, randChoice(TOWER_TYPES), 1);
        this.tutorial.onSummonPressed();
    }
    spawnCheatTower(type, level) {
        const empties = []; for(let r=0;r<GRID_ROWS;r++) { for(let c=0;c<GRID_COLS;c++) { if(!this.grid[r][c]) empties.push({r,c}); } }
        if(empties.length === 0) return;
        const target=empties[0];
        this.placeTowerAtCell(target.r, target.c, type, level);
    }
    spawnTestEnemy(hp) {
        const startPoint = this.pathPoints[0];
        const enemy = this.add.rectangle(startPoint.x, startPoint.y, 30, 36, 0xff4466).setOrigin(0.5).setStrokeStyle(3, 0xffffff);
        enemy.hp = hp;
        enemy.maxHp = hp;
        enemy.speed = ENEMY_BASE_SPEED;
        enemy.isDead = false; enemy.progress = 0;
        enemy.originalFillColor = enemy.fillColor;
        enemy.hpText = this.add.text(enemy.x, enemy.y - 30, `${Math.round(enemy.hp)}`, { fontSize: '16px', color: '#ffffff', fontStyle: 'bold', stroke: '#000', strokeThickness: 4, fontFamily: "'Poppins', Arial, sans-serif" }).setOrigin(0.5).setDepth(150);
        this.enemies.add(enemy);
        this.moveEnemyAlongPath(enemy);
    }
    getCurrentSummonCost() {
        return BASE_SUMMON_COST + (this.summonCount * 5);
    }
    placeTowerAtCell(r, c, type, level){
        if(this.grid[r][c] && this.grid[r][c].tower) return;
        const cx=GRID_X+c*CELL_SIZE+CELL_SIZE/2, cy=GRID_Y+r*CELL_SIZE+CELL_SIZE/2;
        const sprite=this.add.rectangle(cx,cy,CELL_SIZE-TILE_PADDING-6,CELL_SIZE-TILE_PADDING-6,TOWER_CONFIG[type].color).setStrokeStyle(3,0x000000).setInteractive({draggable:true});
        sprite.setDepth(1);
        const label=this.add.text(cx,cy+(CELL_SIZE/2)-24,`L${level}`,{fontSize:'18px',color:'#000', fontFamily:"'Poppins', Arial, sans-serif", fontStyle:'bold'}).setOrigin(0.5).setDepth(2);
        const tower={sprite,label,r,c,x:cx,y:cy,type,level, lastAttack:0, isRapidFire: false, rapidFireTween: null, buffTween: null};
        this.grid[r][c]=tower; this.towers.push(tower);
        this.updateTowerStats(tower);
        if(type === 'arrow') this.updateArrowTowerBuffs();
    }
    tryPlaceTowerFromSprite(sprite) {
        const draggedTower = this.findTowerBySprite(sprite); if (!draggedTower) { sprite.destroy(); return; }
        const endC = Math.floor((sprite.x - GRID_X) / CELL_SIZE); const endR = Math.floor((sprite.y - GRID_Y) / CELL_SIZE);
        if (endR < 0 || endR >= GRID_ROWS || endC < 0 || endC >= GRID_COLS) { this.returnTowerToOriginalPosition(draggedTower); return; }
        const targetTower = this.grid[endR][endC];
        if (!targetTower || targetTower === draggedTower) { this.returnTowerToOriginalPosition(draggedTower); return; }
        if (this.canMerge(draggedTower, targetTower)) { this.mergeTowers(draggedTower, targetTower, endR, endC); }
        else { this.returnTowerToOriginalPosition(draggedTower); }
    }
    canMerge(t1,t2){return t1.type===t2.type&&t1.level===t2.level;}
    mergeTowers(t1,t2,tr,tc){
        const oldType = t1.type;
        this.grid[t1.r][t1.c] = null;
        if (t1.type === 'mana' || t2.type === 'mana') {
            const manaLevel = Math.max(t1.level, t2.level);
            const manaBonus = 15 + (manaLevel * 10);
            this.mana += manaBonus;
            this.showFloatingText(GRID_X+tc*CELL_SIZE+CELL_SIZE/2, GRID_Y+tr*CELL_SIZE+CELL_SIZE/2 - 50, `+${manaBonus} MANA`, '#9966ff', -30, 1200, 20);
        }
        this.destroyTower(t1); this.destroyTower(t2);
        const newLevel=t1.level+1; let newType;
        if (Math.random() < 0.5) {
            newType = randChoice(TOWER_TYPES);
            this.showFloatingText(GRID_X+tc*CELL_SIZE+CELL_SIZE/2, GRID_Y+tr*CELL_SIZE+CELL_SIZE/2 - 40, 'TYPE CHANGED!', '#ff4444', -25, 1000, 16);
        } else { newType = oldType; }
        this.placeTowerAtCell(tr,tc,newType,newLevel);
        const fx=this.add.circle(GRID_X+tc*CELL_SIZE+CELL_SIZE/2, GRID_Y+tr*CELL_SIZE+CELL_SIZE/2, 40, 0xffffff, 0.8);
        this.tweens.add({targets:fx,scale:2.5,alpha:0,duration:300, onComplete:()=>fx.destroy()});

        if (oldType === 'arrow' || newType === 'arrow') {
            this.updateArrowTowerBuffs();
        }
    }
    returnTowerToOriginalPosition(t){
        t.sprite.x=t.x; t.sprite.y=t.y;
        t.label.x = t.x; t.label.y = t.y + (CELL_SIZE/2) - 24;
    }
    findTowerBySprite(s){return this.towers.find(t=>t.sprite===s);}
    destroyTower(t){
        const type = t.type;
        if (t.rapidFireTween) t.rapidFireTween.stop();
        if (t.buffTween) t.buffTween.stop();
        
        // Properly destroy sprite and label
        if(t.sprite) {
            this.tweens.killTweensOf(t.sprite);
            t.sprite.destroy();
        }
        if(t.label) {
            this.tweens.killTweensOf(t.label);
            t.label.destroy();
        }
        
        this.grid[t.r][t.c]=null;
        const i=this.towers.indexOf(t); 
        if(i>=0) this.towers.splice(i,1);
        
        if(type === 'arrow') this.updateArrowTowerBuffs();
    }
    updateTowerStats(tower) {
        tower.baseDmg = TOWER_CONFIG[tower.type].baseDmg * Math.pow(1.4, tower.level-1);
        tower.baseAttackRate = Math.max(300 - (tower.level-1) * 20, 150);
        tower.dmg = tower.baseDmg;
        tower.attackRate = tower.baseAttackRate;
    }
    updateArrowTowerBuffs() {
        const arrowTowers = this.towers.filter(t => t.type === 'arrow');
        arrowTowers.forEach(t => {
            this.updateTowerStats(t);
            if (t.buffTween) {
                t.buffTween.stop();
                t.sprite.setAlpha(1.0);
            }
            t.sprite.setStrokeStyle(3, 0x000000);
            t.buffTween = null;
        });

        const checked = new Set();
        for (const tower of arrowTowers) {
            if (checked.has(tower)) continue;

            const cluster = [];
            const queue = [tower];
            checked.add(tower);

            while(queue.length > 0) {
                const current = queue.shift();
                cluster.push(current);
                const neighbors = [
                    {r: current.r - 1, c: current.c}, {r: current.r + 1, c: current.c},
                    {r: current.r, c: current.c - 1}, {r: current.r, c: current.c + 1}
                ];
                for (const n of neighbors) {
                    if (n.r >= 0 && n.r < GRID_ROWS && n.c >= 0 && n.c < GRID_COLS) {
                        const neighborTower = this.grid[n.r][n.c];
                        if (neighborTower && neighborTower.type === 'arrow' && !checked.has(neighborTower)) {
                            checked.add(neighborTower);
                            queue.push(neighborTower);
                        }
                    }
                }
            }

            if (cluster.length > 1) {
                const totalLevel = cluster.reduce((sum, t) => sum + t.level, 0);
                const damageBonus = 1 + (cluster.length - 1) * 0.15 + totalLevel * 0.05;
                const speedBonus = 1 - Math.min(0.5, (cluster.length - 1) * 0.05 + totalLevel * 0.01);

                for (const t of cluster) {
                    t.dmg = t.baseDmg * damageBonus;
                    t.attackRate = t.baseAttackRate * speedBonus;
                    if (!t.buffTween) {
                         t.sprite.setStrokeStyle(3, 0xffffff);
                         t.buffTween = this.tweens.add({
                            targets: t.sprite,
                            alpha: 0.7,
                            duration: 500,
                            yoyo: true,
                            repeat: -1
                         });
                    }
                }
            }
        }
    }
    spawnEnemy(){
        const startPoint=this.pathPoints[0];
        const enemy=this.add.rectangle(startPoint.x,startPoint.y,30,36,0xff4466).setOrigin(0.5).setStrokeStyle(3, 0xffffff);
        enemy.hp=(ENEMY_BASE_HP + Math.floor(this.score * 0.05)) * this.enemyHpMultiplier;
        enemy.maxHp = enemy.hp;
        enemy.speed = ENEMY_BASE_SPEED;
        enemy.isDead=false; enemy.progress=0; enemy.isMedium=false; enemy.isBoss=false;
        enemy.isSpeedy = false; enemy.isMana = false;
        enemy.originalFillColor = enemy.fillColor;
        enemy.hpText = this.add.text(enemy.x, enemy.y - 30, `${Math.round(enemy.hp)}`, { fontSize: '16px', color: '#ffffff', fontStyle: 'bold', stroke: '#000', strokeThickness: 4, fontFamily: "'Poppins', Arial, sans-serif" }).setOrigin(0.5).setDepth(150);
        this.enemies.add(enemy); this.moveEnemyAlongPath(enemy);
    }
    spawnMediumEnemy() {
        const startPoint = this.pathPoints[0];
        const mediumEnemy = this.add.rectangle(startPoint.x, startPoint.y, 40, 46, 0xff8800).setOrigin(0.5).setStrokeStyle(3, 0xffffff);
        mediumEnemy.hp = (MEDIUM_ENEMY_HP + Math.floor(this.score * 0.05)) * this.enemyHpMultiplier;
        mediumEnemy.maxHp = mediumEnemy.hp;
        mediumEnemy.speed = MEDIUM_ENEMY_SPEED;
        mediumEnemy.isDead = false; mediumEnemy.progress = 0; mediumEnemy.isMedium = true; mediumEnemy.isBoss = false;
        mediumEnemy.isSpeedy = false; mediumEnemy.isMana = false;
        mediumEnemy.originalFillColor = mediumEnemy.fillColor;
        mediumEnemy.hpText = this.add.text(mediumEnemy.x, mediumEnemy.y - 40, `${Math.round(mediumEnemy.hp)}`, { fontSize: '20px', color: '#ffffff', fontStyle: 'bold', stroke: '#000', strokeThickness: 4, fontFamily: "'Poppins', Arial, sans-serif" }).setOrigin(0.5).setDepth(150);
        this.enemies.add(mediumEnemy); this.moveEnemyAlongPath(mediumEnemy);
    }
    spawnSpeedyEnemy() {
        const startPoint = this.pathPoints[0];
        const speedyEnemy = this.add.rectangle(startPoint.x, startPoint.y, 25, 30, 0x33ccff).setOrigin(0.5).setStrokeStyle(2, 0xffffff);
        speedyEnemy.hp = (SPEEDY_ENEMY_HP + Math.floor(this.score * 0.05)) * this.enemyHpMultiplier;
        speedyEnemy.maxHp = speedyEnemy.hp;
        speedyEnemy.speed = SPEEDY_ENEMY_SPEED;
        speedyEnemy.isDead = false; speedyEnemy.progress = 0; speedyEnemy.isMedium = false; speedyEnemy.isBoss = false;
        speedyEnemy.isSpeedy = true; speedyEnemy.isMana = false;
        speedyEnemy.originalFillColor = speedyEnemy.fillColor;
        speedyEnemy.hpText = this.add.text(speedyEnemy.x, speedyEnemy.y - 25, `${Math.round(speedyEnemy.hp)}`, { fontSize: '14px', color: '#ffffff', fontStyle: 'bold', stroke: '#000', strokeThickness: 3, fontFamily: "'Poppins', Arial, sans-serif" }).setOrigin(0.5).setDepth(150);
        this.enemies.add(speedyEnemy); this.moveEnemyAlongPath(speedyEnemy);
    }
    spawnManaEnemy() {
        const startPoint = this.pathPoints[0];
        const manaEnemy = this.add.rectangle(startPoint.x, startPoint.y, 35, 42, 0xcc99ff).setOrigin(0.5).setStrokeStyle(3, 0xffffff);
        manaEnemy.hp = (MANA_ENEMY_HP + Math.floor(this.score * 0.05)) * this.enemyHpMultiplier;
        manaEnemy.maxHp = manaEnemy.hp;
        manaEnemy.speed = ENEMY_BASE_SPEED * 0.9;
        manaEnemy.isDead = false; manaEnemy.progress = 0; manaEnemy.isMedium = false; manaEnemy.isBoss = false;
        manaEnemy.isSpeedy = false; manaEnemy.isMana = true;
        manaEnemy.originalFillColor = manaEnemy.fillColor;
        manaEnemy.hpText = this.add.text(manaEnemy.x, manaEnemy.y - 35, `${Math.round(manaEnemy.hp)}`, { fontSize: '18px', color: '#ffffff', fontStyle: 'bold', stroke: '#000', strokeThickness: 4, fontFamily: "'Poppins', Arial, sans-serif" }).setOrigin(0.5).setDepth(150);
        this.enemies.add(manaEnemy); this.moveEnemyAlongPath(manaEnemy);
    }
    moveEnemyAlongPath(enemy){
        if(!enemy||enemy.isDead)return; enemy.pathSegment=0; this.moveEnemyToNextSegment(enemy);
    }
    moveEnemyToNextSegment(enemy){
        if(!enemy||enemy.isDead||enemy.pathSegment>=this.pathPoints.length-1)return;
        const nextPoint=this.pathPoints[enemy.pathSegment+1]; const distance=this.segmentLengths[enemy.pathSegment];
        const duration=(distance/enemy.speed)*1000; let cumulativeDistance=0;
        for(let i=0;i<enemy.pathSegment;i++)cumulativeDistance+=this.segmentLengths[i];
        this.tweens.add({ targets:enemy,x:nextPoint.x,y:nextPoint.y,duration:duration,ease:'Linear',
            onUpdate:(tween)=>{ if(!enemy||enemy.isDead)return;
                const segmentProgress=tween.progress; const totalProgressAtSegmentStart=cumulativeDistance/this.totalPathLength;
                const segmentWeight=distance/this.totalPathLength; enemy.progress=totalProgressAtSegmentStart+(segmentProgress*segmentWeight);
            },
            onComplete:()=>{ if(!enemy||enemy.isDead)return;
                enemy.pathSegment++;
                if(enemy.pathSegment>=this.pathPoints.length-1){ this.onEnemyReachBase(enemy); }
                else{ this.moveEnemyToNextSegment(enemy); }
            }
        });
    }
    updateTowerAttacks(){
        if(this.isGameOver)return;
        const aliveEnemies=this.enemies.getChildren().filter(e=>e&&!e.isDead); if(aliveEnemies.length===0)return;
        const now=this.time.now;
        for(let tower of this.towers){
            if (tower.isRapidFire && now - tower.lastAttack < tower.attackRate / 3) continue;
            if(!tower.isRapidFire && now - tower.lastAttack < tower.attackRate) continue;

            let bestTarget=null,bestProgress=-1;
            for(let enemy of aliveEnemies){ if(enemy.progress>bestProgress){ bestProgress=enemy.progress; bestTarget=enemy; }}
            if(bestTarget){ this.towerAttack(tower,bestTarget); tower.lastAttack=now; }
        }
    }
    towerAttack(tower,enemy){
        // Check for L5 special first
        if (tower.level >= 5) {
            const config = TOWER_CONFIG[tower.type];
            // Increase chance based on level above 5
            const lv5BaseChance = config.lv5Chance + (tower.level - 5) * 0.05;
            
            if (Math.random() < lv5BaseChance) {
                const specialTriggered = this.applyLv5Special(tower, enemy);
                if (specialTriggered) return;
            }
        }

        // Normal attack
        const projectile = this.projectilePool.get(tower.x, tower.y); 
        if (!projectile) return;
        projectile.setActive(true).setVisible(true).setTint(TOWER_CONFIG[tower.type].color);
        this.tweens.add({
            targets: projectile,
            x: enemy.x,
            y: enemy.y,
            duration: PROJECTILE_SPEED,
            onComplete: () => { if (projectile.active) { this.projectilePool.killAndHide(projectile); } }
        });
        
        let damage = Math.round(tower.dmg*(0.9+Math.random()*0.2)); 
        const config = TOWER_CONFIG[tower.type];
        let critChance = (tower.type === 'arrow' && tower.isRapidFire) ? 0.75 : config.specialChance;

        if(Math.random() < (critChance + (tower.level-1)*0.05)){
            if(tower.type==='arrow'){
                damage*=2; this.showFloatingText(enemy.x, enemy.y, 'CRIT!', '#ffdd00', -25, 500);
            }else{ this.applySpecialEffect(tower,enemy); }
        }
        enemy.hp-=damage; 
        this.showFloatingText(enemy.x, enemy.y, Math.round(damage), '#ffffff');
        if(enemy.hp<=0)this.killEnemy(enemy);
    }
    showFloatingText(x, y, message, color, yOffset = -40, duration = 800, fontSize = 22) {
        const text = this.floatingTextPool.get();
        if (text) {
             const textStyle = { fontSize: `${fontSize}px`, fontStyle: 'bold', stroke: '#000', strokeThickness: 4, fontFamily: "'Poppins', Arial, sans-serif", color: color };
            text.setText(message).setStyle(textStyle).setOrigin(0.5, 0.5).setPosition(x, y)
                .setAlpha(1).setDepth(200).setActive(true).setVisible(true);
            this.tweens.add({ targets: text, y: y + yOffset, alpha: 0, duration: duration, ease: 'Power1.easeOut',
                onComplete: () => { if (text.active) { this.floatingTextPool.killAndHide(text); } }
            });
        }
    }
    castUltimate() {
        if (this.isGameOver || this.time.now - this.lastUltimateTime < ULTIMATE_COOLDOWN) return;
        this.lastUltimateTime = this.time.now; this.ultimateReady = false;
        this.scene.get('UIScene').showUltimateText(); this.cameras.main.shake(200, 0.015);

        const currentExplosionDmg = ULTIMATE_EXPLOSION_DMG * (1 + this.loop * 0.5);
        const currentFireDmg = ULTIMATE_FIRE_DMG * (1 + this.loop * 0.4);

        const aliveEnemies = this.enemies.getChildren().filter(e => e && !e.isDead);
        aliveEnemies.forEach(target => {
            const explosionX = target.x, explosionY = target.y;
            const explosionFx = this.add.circle(explosionX, explosionY, 8, 0xffdd00, 0.9).setDepth(180);
            this.tweens.add({ targets: explosionFx, radius: ULTIMATE_EXPLOSION_RADIUS, alpha: 0, duration: 300, ease: 'Quad.easeOut', onComplete: () => explosionFx.destroy() });
            aliveEnemies.forEach(enemyInRadius => {
                const distance = Phaser.Math.Distance.Between(explosionX, explosionY, enemyInRadius.x, enemyInRadius.y);
                if (distance < ULTIMATE_EXPLOSION_RADIUS) {
                    const damage = Math.round(currentExplosionDmg * (1 - (distance / ULTIMATE_EXPLOSION_RADIUS)));
                    enemyInRadius.hp -= damage;
                    this.showFloatingText(enemyInRadius.x, enemyInRadius.y, damage, '#ffdd00');
                    if (enemyInRadius.hp <= 0) this.killEnemy(enemyInRadius);
                }
            });
            const fireZoneVisual = this.add.graphics({fillStyle: { color: 0xff6600, alpha: 0.3 }, lineStyle: { width: 3, color: 0xff0000, alpha: 0.7 } }).setDepth(5);
            fireZoneVisual.fillCircle(explosionX, explosionY, ULTIMATE_EXPLOSION_RADIUS).strokeCircle(explosionX, explosionY, ULTIMATE_EXPLOSION_RADIUS);
            const newZone = { x: explosionX, y: explosionY, radius: ULTIMATE_EXPLOSION_RADIUS, damage: currentFireDmg, visual: fireZoneVisual, endTime: this.time.now + ULTIMATE_FIRE_ZONE_DURATION };
            this.fireZones.push(newZone);
            this.tweens.add({ targets: fireZoneVisual, alpha: 0, duration: 500, delay: ULTIMATE_FIRE_ZONE_DURATION - 500, onComplete: () => { fireZoneVisual.destroy(); this.fireZones = this.fireZones.filter(z => z !== newZone); } });
        });
        this.time.delayedCall(ULTIMATE_COOLDOWN, () => { this.ultimateReady = true; });
    }
    applySpecialEffect(tower, enemy){
        switch(tower.type){
            case 'fire': this.applyBurn(enemy, 3 + tower.level, 2000); break;
            case 'ice': this.applySlow(enemy, 0.5, 1500); break;
            case 'lightning': this.applyStrictChain(enemy, tower.dmg * 0.6, 2 + tower.level); break;
            case 'poison': this.applyPoison(enemy, 4 + tower.level, 2500); break;
        }
    }
    applyLv5Special(tower, enemy) {
        switch(tower.type) {
            case 'fire': return this.lv5Fire(tower);
            case 'poison': return this.lv5Poison(tower);
            case 'ice': return this.lv5Ice(tower, enemy);
            case 'lightning': return this.lv5Lightning(tower, enemy);
            case 'arrow': return this.lv5Arrow(tower);
        }
        return false;
    }
    lv5Fire(tower) {
        if (this.isMeteorFalling) return false;
        this.isMeteorFalling = true;

        const randomEnemy = randChoice(this.enemies.getChildren().filter(e => e && !e.isDead));
        if (!randomEnemy) { this.isMeteorFalling = false; return false; }

        const meteor = this.add.circle(randomEnemy.x, randomEnemy.y - 400, 20, 0xff6a00).setDepth(180);
        this.tweens.add({
            targets: meteor, y: randomEnemy.y, duration: 500, ease: 'Cubic.easeIn',
            onComplete: () => {
                this.cameras.main.shake(100, 0.005);
                const explosionFx = this.add.circle(randomEnemy.x, randomEnemy.y, 8, 0xffdd00, 0.9).setDepth(180);
                this.tweens.add({ targets: explosionFx, radius: 80, alpha: 0, duration: 300, ease: 'Quad.easeOut', onComplete: () => explosionFx.destroy() });

                const damage = (tower.dmg * 2.5) * (1 + (tower.level - 5) * 0.2);
                this.enemies.getChildren().forEach(e => {
                    if (e && !e.isDead && Phaser.Math.Distance.Between(randomEnemy.x, randomEnemy.y, e.x, e.y) < 80) {
                        e.hp -= damage;
                        this.showFloatingText(e.x, e.y, Math.round(damage), '#ff6a00');
                        if (e.hp <= 0) this.killEnemy(e);
                    }
                });
                meteor.destroy();
                this.isMeteorFalling = false;
            }
        });
        return true;
    }

    lv5Poison(tower) {
        if (this.time.now - this.lastPoisonPoolTime < 3000) return false;
        this.lastPoisonPoolTime = this.time.now;

        const frontEnemy = this.enemies.getChildren().filter(e => e && !e.isDead).sort((a,b) => b.progress - a.progress)[0];
        if (!frontEnemy) return false;

        const radius = 60;
        const duration = 5000 + (tower.level - 5) * 500;
        const damage = (tower.dmg * 0.5) * (1 + (tower.level - 5) * 0.2);
        const visual = this.add.graphics({fillStyle: { color: 0x8fce00, alpha: 0.4 }}).setDepth(4);
        visual.fillCircle(frontEnemy.x, frontEnemy.y, radius);
        const newPool = { x: frontEnemy.x, y: frontEnemy.y, radius, damage, visual, endTime: this.time.now + duration };
        this.poisonPools.push(newPool);

        this.tweens.add({ targets: visual, alpha: 0, duration: 500, delay: duration - 500, onComplete: () => {
            visual.destroy();
            this.poisonPools = this.poisonPools.filter(p => p !== newPool);
        }});
        return true;
    }

    lv5Ice(tower, enemy) {
        if (enemy.isBoss) return false;
        if (enemy.isFrozen) return false;

        enemy.isFrozen = true;
        // Pause movement tween
        const movementTween = this.tweens.getTweensOf(enemy).find(t => t.isPlaying() && (t.data.some(d => d.key === 'x') || t.data.some(d => d.key === 'y')));
        if (movementTween) movementTween.pause();
        
        enemy.setFillStyle(0xaaaaff);

        const freezeDuration = 3000 + (tower.level - 5) * 200;
        const slowDuration = 2000;
        const shatterDamage = (tower.dmg * 1.5) * (1 + (tower.level - 5) * 0.2);
        const shatterRadius = 50;
        
        // Store freeze position
        const freezeX = enemy.x;
        const freezeY = enemy.y;

        this.time.delayedCall(freezeDuration, () => {
            if (!enemy || !enemy.active || enemy.isDead || !enemy.isFrozen) return;

            // Create stationary shatter visual at freeze position
            const shatterVisual = this.add.graphics({fillStyle: { color: 0x66ccff, alpha: 0.3 }, lineStyle: { width: 3, color: 0x66ccff, alpha: 0.7 } }).setDepth(5);
            shatterVisual.fillCircle(freezeX, freezeY, shatterRadius);
            shatterVisual.strokeCircle(freezeX, freezeY, shatterRadius);
            
            // Fade out and destroy immediately
            this.tweens.add({ 
                targets: shatterVisual, 
                alpha: 0, 
                duration: 300, 
                onComplete: () => shatterVisual.destroy() 
            });

            // Apply shatter damage to nearby enemies at freeze position
            this.enemies.getChildren().forEach(e => {
                if (e && e.active && !e.isDead && Phaser.Math.Distance.Between(freezeX, freezeY, e.x, e.y) < shatterRadius) {
                    e.hp -= shatterDamage;
                    this.showFloatingText(e.x, e.y, Math.round(shatterDamage), '#66ccff');
                    if (e.hp <= 0) this.killEnemy(e);
                }
            });

            // Reset enemy color and unfreeze
            enemy.setFillStyle(enemy.originalFillColor);
            enemy.isFrozen = false;
            
            // Resume movement tween
            const movementTween = this.tweens.getTweensOf(enemy).find(t => t.isPaused());
            if (movementTween) movementTween.resume();
            
            // Apply slow after freeze ends
            this.applySlow(enemy, 0.5, slowDuration);
        });
        return true;
    }

    lv5Lightning(tower, enemy) {
        const primaryDamage = tower.dmg * 3;
        enemy.hp -= primaryDamage;
        this.showFloatingText(enemy.x, enemy.y, Math.round(primaryDamage), '#ffff00');
        if (enemy.hp <= 0) {
            this.killEnemy(enemy);
            return true;
        }

        const maxChains = 3 + Math.floor((tower.level - 5) / 2);
        const stunDuration = 500;

        let lastEnemy = enemy;
        const chainedEnemies = [enemy];

        for(let i=0; i<maxChains; i++) {
            const nearby = this.enemies.getChildren().filter(e =>
                e && !e.isDead && !chainedEnemies.includes(e) &&
                Phaser.Math.Distance.Between(lastEnemy.x, lastEnemy.y, e.x, e.y) < 150
            );

            if (nearby.length > 0) {
                const nextTarget = nearby[0];
                
                // Create chain line visual
                const chainLine = this.add.line(0, 0, lastEnemy.x, lastEnemy.y, nextTarget.x, nextTarget.y, 0xffff66, 0.9)
                    .setLineWidth(5, 2).setDepth(150);
                this.tweens.add({ 
                    targets: chainLine, 
                    alpha: 0, 
                    duration: 300, 
                    onComplete: () => chainLine.destroy() 
                });

                const chainDamage = tower.dmg * 0.8;
                nextTarget.hp -= chainDamage;
                this.showFloatingText(nextTarget.x, nextTarget.y, Math.round(chainDamage), '#ffff66');
                
                if (nextTarget.hp <= 0) {
                    this.killEnemy(nextTarget);
                    chainedEnemies.push(nextTarget);
                    lastEnemy = nextTarget;
                    continue;
                }

                // Apply stun
                if (!nextTarget.isStunned) {
                    nextTarget.isStunned = true;
                    // Only pause movement tween
                    const movementTween = this.tweens.getTweensOf(nextTarget).find(t => 
                        t.isPlaying() && (t.data.some(d => d.key === 'x') || t.data.some(d => d.key === 'y'))
                    );
                    if (movementTween) movementTween.pause();
                    
                    this.time.delayedCall(stunDuration, () => {
                        if (nextTarget && nextTarget.active && !nextTarget.isDead) {
                            const movementTween = this.tweens.getTweensOf(nextTarget).find(t => 
                                t.isPaused() && (t.data.some(d => d.key === 'x') || t.data.some(d => d.key === 'y'))
                            );
                            if (movementTween) movementTween.resume();
                            nextTarget.isStunned = false;
                        }
                    });
                }

                chainedEnemies.push(nextTarget);
                lastEnemy = nextTarget;
            } else {
                break;
            }
        }
        return true;
    }


    lv5Arrow(tower) {
        if (tower.isRapidFire) return false;
        tower.isRapidFire = true;
        
        if (tower.rapidFireTween) tower.rapidFireTween.stop();
        tower.sprite.setScale(1);
        tower.rapidFireTween = this.tweens.add({
            targets: tower.sprite,
            scale: 1.15,
            duration: 250,
            yoyo: true,
            repeat: -1
        });

        this.time.delayedCall(5000, () => {
            if (tower && tower.sprite) {
                tower.isRapidFire = false;
                if (tower.rapidFireTween) {
                    tower.rapidFireTween.stop();
                    tower.sprite.setScale(1);
                }
            }
        });
        return false;
    }
    applyBurn(enemy, damagePerTick, duration){
        if(!enemy || enemy.isDead) return;
        const burnTimer = this.time.addEvent({ delay: 500, repeat: Math.floor(duration/500)-1, callback: () => {
                if(!enemy || !enemy.active || enemy.isDead) { burnTimer.destroy(); return; }
                enemy.hp -= damagePerTick; this.showFloatingText(enemy.x, enemy.y, damagePerTick, '#ff6a00');
                if(enemy.hp <= 0) this.killEnemy(enemy);
        }});
    }
    applySlow(enemy, slowFactor, duration){
        if(!enemy || enemy.isDead || enemy.isSlowed) return;
        enemy.isSlowed = true;
        this.tweens.getTweensOf(enemy).forEach(tween => { tween.timeScale = (1 - slowFactor); });
        this.time.delayedCall(duration, () => { if(enemy && enemy.active && !enemy.isDead) { enemy.isSlowed = false; this.tweens.getTweensOf(enemy).forEach(tween => { tween.timeScale = 1; }); } });
    }
    applyStrictChain(sourceEnemy, damage, maxTargets){
        if(!sourceEnemy || sourceEnemy.isDead) return;
        const sameSegmentEnemies = this.enemies.getChildren().filter(e => e && !e.isDead && e !== sourceEnemy && e.pathSegment === sourceEnemy.pathSegment && e.progress < sourceEnemy.progress).sort((a,b) => b.progress - a.progress).slice(0, maxTargets);
        let lastEnemy = sourceEnemy;
        for(let enemy of sameSegmentEnemies){
            const roundedDamage = Math.round(damage);
            enemy.hp -= roundedDamage; this.showFloatingText(enemy.x, enemy.y, roundedDamage, '#ffff66');
            const chainLine = this.add.line(0, 0, lastEnemy.x, lastEnemy.y, enemy.x, enemy.y, 0xffff66, 0.8).setLineWidth(4, 2);
            this.tweens.add({ targets: chainLine, alpha: 0, duration: 250, onComplete: () => chainLine.destroy() });
            if(enemy.hp <= 0) this.killEnemy(enemy);
            lastEnemy = enemy;
        }
    }
    applyPoison(enemy, damagePerTick, duration){
        if(!enemy || enemy.isDead || enemy.isPoisoned) return;
        enemy.isPoisoned = true;
        const poisonTimer = this.time.addEvent({ delay: 500, repeat: Math.floor(duration/500)-1, callback: () => {
                if(!enemy || !enemy.active || enemy.isDead) { poisonTimer.destroy(); return; }
                enemy.hp -= damagePerTick; this.showFloatingText(enemy.x, enemy.y, damagePerTick, '#8fce00');
                if(enemy.hp <= 0) this.killEnemy(enemy);
            }, onComplete: () => { if(enemy && !enemy.isDead) enemy.isPoisoned = false; }
        });
    }
}

/* =========================
    SCENE: UIScene
   ========================= */
class UIScene extends Phaser.Scene {
    constructor(){ super({key: 'UIScene', active: true}); }

    create(){
        this.gameScene = this.scene.get('GameScene');
        this.fontStyle = { fontFamily: "'Poppins', Arial, sans-serif", fontSize: '32px', color: '#fff', fontStyle: '700' };

        const summonBtnBg = this.add.graphics();
        this.summonBtn = this.add.zone(WIDTH/2-140, HEIGHT-110, 280, 80).setOrigin(0).setInteractive();
        this.summonText = this.add.text(WIDTH/2, HEIGHT-70, `SUMMON`, this.fontStyle).setOrigin(0.5);
        this.summonBtn.on('pointerdown', () => this.gameScene.doSummon());
        this.ultimateBtnBg = this.add.graphics();
        this.ultimateCooldownIndicator = this.add.graphics();
        const ultBtnX = WIDTH - 180, ultTextX = WIDTH - 105;
        this.ultimateBtn = this.add.zone(ultBtnX, HEIGHT - 110, 150, 80).setOrigin(0).setInteractive();
        this.ultimateText = this.add.text(ultTextX, HEIGHT - 70, 'ULTIMATE', { ...this.fontStyle, fontSize: '24px' }).setOrigin(0.5);
        this.ultimateBtn.on('pointerdown', () => this.gameScene.castUltimate());
        this.hpText = this.add.text(30, 30, `HP: 0`, this.fontStyle).setOrigin(0,0);
        this.scoreText = this.add.text(WIDTH-30, 30, `Score: 0`, this.fontStyle).setOrigin(1,0);
        this.waveText = this.add.text(WIDTH/2, 80, `Wave: 0`, {...this.fontStyle, fontSize: '24px'}).setOrigin(0.5,0);
        this.manaText = this.add.text(30, 80, `Mana: 0`, this.fontStyle).setOrigin(0,0);
        this.bossTimerText = this.add.text(WIDTH/2, 30, '', { ...this.fontStyle, fontSize: '28px' }).setOrigin(0.5,0);
        this.createTowerLegend();
        this.inGameUI = [summonBtnBg, this.summonBtn, this.summonText, this.manaText, this.scoreText, this.hpText, this.waveText, this.bossTimerText, this.ultimateBtnBg, this.ultimateCooldownIndicator, this.ultimateBtn, this.ultimateText, this.towerLegendGroup];
        
        this.createGameOverCta();

        const formHTML = `
            <style>
                #score-form-container-ingame {
                    width: 400px; padding: 2rem; background-color: #161b22;
                    border-radius: 15px; border: 2px solid #30363d;
                    box-shadow: 0 5px 20px rgba(0,0,0,0.5); text-align: center;
                    font-family: 'Poppins', sans-serif;
                }
                #score-form-container-ingame input {
                    width: 100%; padding: 0.75rem; margin-top: 1rem; margin-bottom: 1.5rem;
                    border-radius: 8px; border: 1px solid #444; background-color: #0d1117;
                    color: white; font-size: 1.2rem;
                }
                #score-form-container-ingame button {
                    width: 100%; padding: 0.75rem; border: none; border-radius: 8px;
                    background-color: #1f8fff; color: white; font-size: 1.2rem;
                    font-weight: bold; cursor: pointer; transition: background-color 0.2s;
                }
                #score-form-container-ingame button:hover { background-color: #3c9cff; }
            </style>
            <div id="score-form-container-ingame">
                <h3 id="form-title" style="color: white; font-weight: bold;">SUBMIT YOUR SCORE</h3>
                <p style="color: #aaa;">Your Score: <span id="final-score" style="color: #ffc107;">0</span></p>
                <form id="submit-score-form">
                    <input type="text" id="player-name" placeholder="Enter Your Name..." required maxlength="15">
                    <button type="submit">SUBMIT</button>
                </form>
            </div>
        `;

        this.formElement = this.add.dom(WIDTH / 2, HEIGHT / 2 + 50).createFromHTML(formHTML);
        this.formElement.setVisible(false);
        this.formElement.setDepth(6000);

        this.bossAnnouncementText = this.add.text(WIDTH/2, 120, '', { 
            fontSize: '28px', color: '#ffff00', fontStyle: 'bold', 
            fontFamily: "'Poppins', Arial, sans-serif",
            stroke: '#000', strokeThickness: 5,
            align: 'center',
            wordWrap: { width: 400 }
        }).setOrigin(0.5).setDepth(150).setVisible(false);

        this.bossDescriptionText = this.add.text(WIDTH/2, 160, '', { 
            fontSize: '16px', color: '#ffffff', fontStyle: 'normal', 
            fontFamily: "'Poppins', Arial, sans-serif",
            stroke: '#000', strokeThickness: 3,
            align: 'center',
            wordWrap: { width: 400 }
        }).setOrigin(0.5).setDepth(150).setVisible(false);
    }

    createTowerLegend() {
        this.towerLegendGroup = this.add.group();
        const legendY = HEIGHT - 220; const title = this.add.text(WIDTH/2, legendY - 40, 'TOWER TYPES', { fontSize: '22px', color: '#fff', fontStyle: 'bold', fontFamily: "'Poppins', Arial, sans-serif" }).setOrigin(0.5);
        const types = ['fire', 'ice', 'lightning', 'poison', 'arrow', 'mana'];
        const spacing = 96, startX = (WIDTH - (types.length - 1) * spacing) / 2;
        types.forEach((type, i) => {
            const x = startX + spacing * i;
            const rect = this.add.rectangle(x, legendY, 28, 22, TOWER_CONFIG[type].color).setStrokeStyle(2, 0x333333);
            const nameText = (type === 'lightning') ? 'BOLT' : type.toUpperCase();
            const effectText = {fire:'Burn',ice:'Slow',lightning:'Chain',poison:'DoT',arrow:'Crit',mana:'Bonus'}[type];
            const name = this.add.text(x, legendY + 22, nameText, {fontSize: '14px', color: '#fff', fontStyle: 'bold'}).setOrigin(0.5);
            const effect = this.add.text(x, legendY + 40, effectText, {fontSize: '12px', color: '#aaa'}).setOrigin(0.5);
            this.towerLegendGroup.addMultiple([rect, name, effect]);
        });
        this.towerLegendGroup.add(title);
    }
    
    
    createGameOverCta() {
        this.gameOverGroup = this.add.group();
        const overlay = this.add.rectangle(WIDTH/2,HEIGHT/2,WIDTH,HEIGHT,0x000000,0.8);
        const titleText = this.add.text(WIDTH/2, HEIGHT/2 - 220, 'GAME OVER', {...this.fontStyle, fontSize:'84px', color: '#ff4444'}).setOrigin(0.5);
        const retryButton = this.add.text(WIDTH/2, HEIGHT/2 + 250, 'RETRY', {...this.fontStyle, fontSize: '48px', color: '#66ff66'}).setOrigin(0.5).setInteractive();
        this.gameOverGroup.addMultiple([overlay, titleText, retryButton]);
        this.gameOverGroup.getChildren().forEach(c => c.setDepth(5000));
        this.gameOverGroup.setVisible(false);

        retryButton.on('pointerdown', () => {
            this.scene.stop('GameScene');
            this.scene.start('GameScene');
            this.scene.restart();
        });
    }

    showGameOver(score){
        this.gameScene.freezeGame();
        this.inGameUI.forEach(ui => { if (ui) ui.setVisible(false); });
        this.gameOverGroup.setVisible(true);
        this.formElement.setVisible(true);

        const finalScoreEl = this.formElement.getChildByID('final-score');
        finalScoreEl.innerText = score;

        const form = this.formElement.getChildByID('submit-score-form');
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            const playerNameInput = this.formElement.getChildByID('player-name');
            const playerName = playerNameInput.value.trim();
            if (playerName) {
                const scoreData = { type: 'submitScore', name: playerName, score: score };
                window.parent.postMessage(scoreData, '*');
                this.formElement.setVisible(false);
                this.add.text(WIDTH/2, HEIGHT/2, 'SCORE SUBMITTED!', {...this.fontStyle, fontSize:'48px', color: '#1f8fff'}).setOrigin(0.5).setDepth(6001);
            }
        });
    }
    
    showUltimateText() {
        const ultText = this.add.text(WIDTH/2, HEIGHT/2, 'ULTIMATE!', { fontSize: '92px', color: '#ffdd00', fontStyle: 'bold', stroke: '#ff6600', strokeThickness: 12 }).setOrigin(0.5).setDepth(300).setScale(0.5);
        this.tweens.add({ targets: ultText, scale: 1.2, alpha: 0, duration: 1500, ease: 'Cubic.easeOut', onComplete: () => ultText.destroy() });
    }

    showBossAnnouncement(bossName, description, bossColor) {
        // Clear any existing tweens on these texts
        this.tweens.killTweensOf(this.bossAnnouncementText);
        this.tweens.killTweensOf(this.bossDescriptionText);
        
        this.bossAnnouncementText.setText(`⚠ ${bossName} ⚠`)
            .setColor(bossColor > 0xffffff ? '#ffffff' : `#${bossColor.toString(16).padStart(6, '0')}`)
            .setVisible(true)
            .setAlpha(0);
        
        this.bossDescriptionText.setText(description)
            .setVisible(true)
            .setAlpha(0);
        
        // Fade in announcement
        this.tweens.add({
            targets: [this.bossAnnouncementText, this.bossDescriptionText],
            alpha: 1,
            duration: 400,
            ease: 'Power2.easeOut'
        });
        
        // Keep visible for 5 seconds, then fade out
        this.time.delayedCall(5000, () => {
            this.tweens.add({
                targets: [this.bossAnnouncementText, this.bossDescriptionText],
                alpha: 0,
                duration: 400,
                ease: 'Power2.easeIn',
                onComplete: () => {
                    this.bossAnnouncementText.setVisible(false);
                    this.bossDescriptionText.setVisible(false);
                }
            });
        });
    }

    update(time, delta){
        if(!this.gameScene.sys.isActive() || this.gameScene.isGameOver) return;
        this.manaText.setText(`Mana: ${Math.floor(this.gameScene.mana)}`);
        this.hpText.setText(`HP: ${this.gameScene.playerHP}`);
        this.scoreText.setText(`Score: ${this.gameScene.score}`);
        this.waveText.setText(`Wave: ${this.gameScene.wave}`);

        // Boss timer display at top
        if (this.gameScene.bossSpawned) {
            this.bossTimerText.setY(30).setText('⚠ BOSS INCOMING ⚠').setColor('#ff4444');
        } else {
            const totalSeconds = this.gameScene.timeUntilBoss;
            const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
            const seconds = String(totalSeconds % 60).padStart(2, '0');
            this.bossTimerText.setY(30).setText(`Boss In: ${minutes}:${seconds}`).setColor('#ffffff');
        }
        
        const cost = this.gameScene.getCurrentSummonCost();
        this.summonText.setText(`SUMMON (${cost})`);
        const summonBtnBg = this.inGameUI[0];
        summonBtnBg.clear().fillStyle(this.gameScene.mana >= cost ? 0x1f8fff : 0x666666, 1).fillRoundedRect(WIDTH/2 - 140, HEIGHT - 110, 280, 80, 20);
        
        const timeSinceUltimate = this.game.getTime() - this.gameScene.lastUltimateTime;
        const ultBtnX = WIDTH - 180, ultTextX = WIDTH - 105;
        if (timeSinceUltimate < ULTIMATE_COOLDOWN) {
            this.ultimateText.setText(`${Math.ceil((ULTIMATE_COOLDOWN - timeSinceUltimate) / 1000)}s`);
            this.ultimateBtnBg.clear().fillStyle(0x666666, 1).fillRoundedRect(ultBtnX, HEIGHT - 110, 150, 80, 20);
            const progress = timeSinceUltimate / ULTIMATE_COOLDOWN;
            this.ultimateCooldownIndicator.clear().lineStyle(6, 0x1f8fff, 1).beginPath().arc(ultTextX, HEIGHT - 70, 45, Phaser.Math.DegToRad(-90), Phaser.Math.DegToRad(-90 + 360 * progress), false).strokePath();
        } else {
            this.ultimateText.setText('ULTIMATE');
            this.ultimateBtnBg.clear().fillStyle(0xff4444, 1).fillRoundedRect(ultBtnX, HEIGHT - 110, 150, 80, 20);
            this.ultimateCooldownIndicator.clear();
        }
    }
}
/* =========================
    GAME CONFIG
   ========================= */
const config = {
    type: Phaser.AUTO,
    width: WIDTH, height: HEIGHT, parent: 'game', backgroundColor: '#000011',
    dom: {
        createContainer: true
    },
    render: { powerPreference: 'high-performance' },
    physics: { default: 'arcade', arcade: { debug: false } },
    scene: [GameScene, UIScene],
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH }
};
const game = new Phaser.Game(config);
</script>
</body>
</html>