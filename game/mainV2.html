<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Playable Ad - Merge TD (Balanced & HD)</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin:0; background:#000; font-family: 'Poppins', Arial, sans-serif; }
        #game { margin:0 auto; display:block; }
    </style>
</head>
<body>
    <div id="game"></div>

<script>
/* =========================
    CONFIG / CONSTANTS
   ========================= */
const WIDTH = 648; const HEIGHT = 1080; // <<< แก้ไขแล้ว!
const GRID_COLS = 4; const GRID_ROWS = 5; 
const CELL_SIZE = 110; // <<< แก้ไขแล้ว!
const GRID_W = GRID_COLS * CELL_SIZE; const GRID_H = GRID_ROWS * CELL_SIZE;
const GRID_X = (WIDTH - GRID_W) / 2; 
const GRID_Y = 240; // <<< แก้ไขแล้ว!
const TILE_PADDING = 10; // <<< แก้ไขแล้ว!
const TOWER_TYPES = ['fire','ice','lightning','poison','arrow','mana'];
const TOWER_CONFIG = {
    fire:      { color: 0xff6a00, baseDmg: 15, specialChance: 0.2 },
    ice:       { color: 0x66ccff, baseDmg: 8,  specialChance: 0.25 },
    lightning: { color: 0xffff66, baseDmg: 10, specialChance: 0.25 },
    poison:    { color: 0x8fce00, baseDmg: 6,  specialChance: 0.3 },
    arrow:     { color: 0xffffff, baseDmg: 12, specialChance: 0.25 },
    mana:      { color: 0x9966ff, baseDmg: 8,  specialChance: 0.0 }
};
const ENEMY_BASE_HP = 50; const ENEMY_BASE_SPEED = 120; const ENEMY_SPAWN_DELAY = 1300;
const MEDIUM_ENEMY_HP = 120; const MEDIUM_ENEMY_SPEED = 100; const MEDIUM_MANA_REWARD = 20;
const MANA_REGEN_RATE = 10; const MANA_PER_KILL = 12; const BASE_SUMMON_COST = 10;
const ULTIMATE_COOLDOWN = 30000;
const ULTIMATE_EXPLOSION_DMG = 80;
const ULTIMATE_EXPLOSION_RADIUS = 55; // <<< แก้ไขแล้ว!
const ULTIMATE_FIRE_ZONE_DURATION = 3000;
const ULTIMATE_FIRE_DMG = 15;

function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

/* =========================
    SCENE: GameScene
   ========================= */
class GameScene extends Phaser.Scene {
    constructor(){ super('GameScene'); }
    create(){
        this.playerHP = 5; this.score = 0; this.mana = 30; this.summonCount = 0;
        this.powerUpActive = false; this.bossSpawned = false; this.boss = null; 
        this.difficultyLevel = 0; this.isGameOver = false;
        this.waitingForAllEnemiesToDie = false;
        this.ultimateReady = true; this.lastUltimateTime = -ULTIMATE_COOLDOWN; this.fireZones = [];

        this.add.rectangle(WIDTH/2, HEIGHT/2, WIDTH, HEIGHT, 0x16202a);
        this.setupGrid(); this.setupPath();
        this.towers = []; this.enemies = this.add.group();
        this.setupInputHandling();
        this.physics.pause();
    }
    
    startGame() {
        this.physics.resume();
        this.spawnTimer = this.time.addEvent({ delay: ENEMY_SPAWN_DELAY, loop: true, callback: this.spawnEnemy, callbackScope: this });
        this.towerAttackTimer = this.time.addEvent({ delay: 200, loop: true, callback: this.updateTowerAttacks, callbackScope: this });
        this.manaRegenTimer = this.time.addEvent({ delay: 1000, loop: true, callback: () => { this.mana += MANA_REGEN_RATE; } });
    }
    
    freezeGame() {
        this.isGameOver = true;
        this.physics.pause(); this.tweens.pauseAll();
        if (this.spawnTimer) this.spawnTimer.remove();
        if (this.towerAttackTimer) this.towerAttackTimer.remove();
        if (this.manaRegenTimer) this.manaRegenTimer.remove();
        if (this.bossSpawnTimer) this.bossSpawnTimer.remove();
    }
    
    increaseDifficulty() {
        this.difficultyLevel++;
        if (this.spawnTimer && !this.spawnTimer.paused) {
            this.spawnTimer.delay = Math.max(350, ENEMY_SPAWN_DELAY - (this.difficultyLevel * 100));
        }
    }

    activatePowerUp() {
        if (this.powerUpActive) return;
        this.powerUpActive = true;
        this.towers.forEach(tower => { tower.dmg *= 2; tower.attackRate /= 2; });
        const buffText = this.add.text(WIDTH/2, HEIGHT/2, 'POWER SURGE!', { fontSize: '64px', color: '#ff0', fontStyle: 'bold', stroke: '#000', strokeThickness: 8 }).setOrigin(0.5).setDepth(200);
        this.tweens.add({ targets: buffText, alpha: 0, y: '-=50', duration: 2000, onComplete: () => buffText.destroy() });
    }
    
    spawnBoss() {
        this.bossSpawned = true;
        this.spawnTimer.paused = true;
        const startPoint = this.pathPoints[0];
        const boss = this.add.rectangle(startPoint.x, startPoint.y, 80, 90, 0xcc00ff).setOrigin(0.5).setStrokeStyle(4, 0xffffff);
        boss.hp = ENEMY_BASE_HP * 150;
        boss.maxHp = boss.hp;
        boss.speed = ENEMY_BASE_SPEED * 0.4;
        boss.isDead = false; boss.progress = 0; boss.isBoss = true;
        boss.hpText = this.add.text(boss.x, boss.y - 60, `${Math.round(boss.hp)}`, { fontSize: '28px', color: '#ffffff', fontStyle: 'bold', stroke: '#000', strokeThickness: 5, fontFamily: "'Poppins', Arial, sans-serif" }).setOrigin(0.5).setDepth(150);
        this.enemies.add(boss);
        this.moveEnemyAlongPath(boss);
        this.boss = boss;
        this.spawnMediumEnemies();
        this.bossSpawnTimer = this.time.addEvent({ delay: 5000, loop: true, callback: this.spawnMediumEnemies, callbackScope: this });
    }
    
    killEnemy(enemy){
        if(!enemy || enemy.isDead)return; 
        enemy.isDead = true; 
        
        if (enemy.isBoss) {
            this.score += 200; this.mana += MANA_PER_KILL * 5;
            if (this.bossSpawnTimer) { this.bossSpawnTimer.remove(); this.bossSpawnTimer = null; }
        } else if (enemy.isMedium) {
            this.score += 3; this.mana += MEDIUM_MANA_REWARD;
        } else {
            this.score += 1; this.mana += MANA_PER_KILL;
        }
        
        const targetsToFade = [enemy];
        if (enemy.hpText && enemy.hpText.active) {
            targetsToFade.push(enemy.hpText);
        }

        this.tweens.add({
            targets: targetsToFade,
            alpha: 0, scale: 0.5, duration: 200,
            onComplete: () => {
                if (enemy) {
                    if (enemy.hpText) enemy.hpText.destroy();
                    enemy.destroy();
                }
            }
        });

        if (this.score >= 150 && !this.bossSpawned) this.spawnBoss();
        
        if (enemy === this.boss) {
            this.waitingForAllEnemiesToDie = true;
        }
    }
    
    update(time, delta){
        if (this.isGameOver) return;
        
        this.enemies.getChildren().forEach(enemy => {
            if(enemy && enemy.active && !enemy.isDead && enemy.hpText && enemy.hpText.active) {
                const yOffset = enemy.isBoss ? -70 : (enemy.isMedium ? -40 : -30);
                enemy.hpText.setPosition(enemy.x, enemy.y + yOffset);
                enemy.hpText.setText(`${Math.round(enemy.hp)}`);
                const hpPercent = enemy.hp / enemy.maxHp;
                if (hpPercent < 0.3) enemy.hpText.setColor('#ff4444');
                else if (hpPercent < 0.6) enemy.hpText.setColor('#ffaa33');
                else enemy.hpText.setColor('#ffffff');
            }
        });

        const now = this.time.now;
        this.fireZones.forEach(zone => {
            if(!zone.visual.active) return;
            this.enemies.getChildren().forEach(enemy => {
                if (enemy && !enemy.isDead && Phaser.Math.Distance.Between(zone.x, zone.y, enemy.x, enemy.y) < zone.radius) {
                    if (!enemy.lastFireTick) enemy.lastFireTick = 0;
                    if (now - enemy.lastFireTick > 500) {
                        enemy.lastFireTick = now;
                        enemy.hp -= ULTIMATE_FIRE_DMG;
                        this.showDamageNumber(enemy.x, enemy.y, ULTIMATE_FIRE_DMG, '#ff6600');
                        if (enemy.hp <= 0) this.killEnemy(enemy);
                    }
                }
            });
        });

        if (this.waitingForAllEnemiesToDie) {
            if (this.enemies.getChildren().length === 0) {
                this.waitingForAllEnemiesToDie = false; 
                this.time.delayedCall(1000, this.endGame, [], this);
            }
        }
    }
    
    onEnemyReachBase(enemy){ 
        if(!enemy||enemy.isDead)return; 
        enemy.isDead=true; 
        if (enemy.hpText) enemy.hpText.destroy();
        enemy.destroy(); 
        this.playerHP--; 
        if(this.playerHP<=0) this.endGame(); 
    }
    
    endGame(){ this.scene.get('UIScene').showCta(this.score); }
    
    setupGrid(){
        this.grid = Array(GRID_ROWS).fill(null).map(() => Array(GRID_COLS).fill(null));
        this.add.rectangle(WIDTH/2, GRID_Y + GRID_H/2, GRID_W+20, GRID_H+20, 0x0f1720).setStrokeStyle(3, 0x2b3942); // <<< แก้ไขแล้ว!
        for(let r=0;r<GRID_ROWS;r++) {
            for(let c=0;c<GRID_COLS;c++) {
                this.add.rectangle(GRID_X+c*CELL_SIZE+CELL_SIZE/2, GRID_Y+r*CELL_SIZE+CELL_SIZE/2, CELL_SIZE-TILE_PADDING, CELL_SIZE-TILE_PADDING, 0x0a2533).setStrokeStyle(2, 0x24414e); // <<< แก้ไขแล้ว!
            }
        }
    }
    
    setupPath(){ // <<< แก้ไขแล้ว!
        const m=40, l=GRID_X-m, r=GRID_X+GRID_W+m, t=GRID_Y-m, b=GRID_Y+GRID_H+m;
        this.pathPoints = [{x:l,y:b},{x:l,y:t},{x:r,y:t},{x:r,y:b}];
        this.pathSegments = [{start:{x:l,y:b},end:{x:l,y:t}},{start:{x:l,y:t},end:{x:r,y:t}},{start:{x:r,y:t},end:{x:r,y:b}}];
        const pathGraphics=this.add.graphics(); 
        pathGraphics.lineStyle(5,0x555555); // <<< แก้ไขแล้ว!
        for(let i=0;i<this.pathPoints.length-1;i++) { pathGraphics.lineBetween(this.pathPoints[i].x,this.pathPoints[i].y,this.pathPoints[i+1].x,this.pathPoints[i+1].y); }
        this.totalPathLength=0; this.segmentLengths=[];
        for(let i=0;i<this.pathPoints.length-1;i++){ 
            const d=Phaser.Math.Distance.Between(this.pathPoints[i].x,this.pathPoints[i].y,this.pathPoints[i+1].x,this.pathPoints[i+1].y); 
            this.segmentLengths.push(d); this.totalPathLength+=d; 
        }
    }
    
    setupInputHandling(){
        this.input.on('dragstart', (p, go) => go.setScale(1.1).setDepth(100));
        this.input.on('drag', (p, go, dx, dy) => { go.x = dx; go.y = dy; });
        this.input.on('dragend', (p, go) => { go.setScale(1.0).setDepth(1); this.tryPlaceTowerFromSprite(go); });
    }
    
    doSummon(){
        if(this.isGameOver || this.time.now - this.lastSummon < 500) return;
        const cost = this.getCurrentSummonCost(); 
        if(this.mana < cost) return;
        const empties = []; 
        for(let r=0;r<GRID_ROWS;r++) { for(let c=0;c<GRID_COLS;c++) { if(!this.grid[r][c]) empties.push({r,c}); } }
        if(empties.length === 0) return;
        this.lastSummon=this.time.now; this.mana-=cost; this.summonCount++;
        const target=randChoice(empties); 
        this.placeTowerAtCell(target.r, target.c, randChoice(TOWER_TYPES), 1);
    }
    
    getCurrentSummonCost() { return BASE_SUMMON_COST + (this.summonCount * (this.summonCount + 1)); }
    
    placeTowerAtCell(r, c, type, level){
        if(this.grid[r][c] && this.grid[r][c].tower) return;
        const cx=GRID_X+c*CELL_SIZE+CELL_SIZE/2, cy=GRID_Y+r*CELL_SIZE+CELL_SIZE/2;
        const sprite=this.add.rectangle(cx,cy,CELL_SIZE-TILE_PADDING-6,CELL_SIZE-TILE_PADDING-6,TOWER_CONFIG[type].color).setStrokeStyle(3,0x000000).setInteractive({draggable:true}); // <<< แก้ไขแล้ว!
        sprite.setDepth(1);
        const label=this.add.text(cx,cy+(CELL_SIZE/2)-24,`L${level}`,{fontSize:'18px',color:'#000', fontFamily:"'Poppins', Arial, sans-serif", fontStyle:'bold'}).setOrigin(0.5).setDepth(2); // <<< แก้ไขแล้ว!
        let towerDmg=TOWER_CONFIG[type].baseDmg*Math.pow(1.4,level-1);
        let towerAttackRate=Math.max(300-(level-1)*20,150);
        if(this.powerUpActive){towerDmg*=2;towerAttackRate/=2;}
        const tower={sprite,label,r,c,x:cx,y:cy,type,level,dmg:towerDmg,attackRate:towerAttackRate,lastAttack:0};
        this.grid[r][c]=tower; this.towers.push(tower);
    }
    
    tryPlaceTowerFromSprite(sprite) {
        const draggedTower = this.findTowerBySprite(sprite);
        if (!draggedTower) { sprite.destroy(); return; }
        const endC = Math.floor((sprite.x - GRID_X) / CELL_SIZE);
        const endR = Math.floor((sprite.y - GRID_Y) / CELL_SIZE);
        if (endR < 0 || endR >= GRID_ROWS || endC < 0 || endC >= GRID_COLS) { this.returnTowerToOriginalPosition(draggedTower); return; }
        const targetTower = this.grid[endR][endC];
        if (!targetTower || targetTower === draggedTower) { this.returnTowerToOriginalPosition(draggedTower); return; }
        if (this.canMerge(draggedTower, targetTower)) { this.mergeTowers(draggedTower, targetTower, endR, endC); } 
        else { this.returnTowerToOriginalPosition(draggedTower); }
    }

    canMerge(t1,t2){return t1.type===t2.type&&t1.level===t2.level;}
    
    mergeTowers(t1,t2,tr,tc){ 
        this.grid[t1.r][t1.c] = null;
        if (t1.type === 'mana' || t2.type === 'mana') {
            const manaLevel = Math.max(t1.level, t2.level);
            const manaBonus = 15 + (manaLevel * 10);
            this.mana += manaBonus;
            const manaText = this.add.text(GRID_X+tc*CELL_SIZE+CELL_SIZE/2, GRID_Y+tr*CELL_SIZE+CELL_SIZE/2-50, `+${manaBonus} MANA`, {fontSize:'20px',color:'#9966ff',fontStyle:'bold',fontFamily:"'Poppins', Arial, sans-serif"}).setOrigin(0.5); // <<< แก้ไขแล้ว!
            this.tweens.add({targets: manaText, alpha: 0, y: '-=30', duration: 1200, onComplete: () => manaText.destroy()});
        }
        this.destroyTower(t1); this.destroyTower(t2); 
        const newLevel=t1.level+1;
        let newType;
        if (Math.random() < 0.3) {
            newType = randChoice(TOWER_TYPES);
            const riskText = this.add.text(GRID_X+tc*CELL_SIZE+CELL_SIZE/2, GRID_Y+tr*CELL_SIZE+CELL_SIZE/2-40, 'TYPE CHANGED!', {fontSize:'16px',color:'#ff4444',fontStyle:'bold',fontFamily:"'Poppins', Arial, sans-serif"}).setOrigin(0.5); // <<< แก้ไขแล้ว!
            this.tweens.add({targets: riskText, alpha: 0, y: '-=25', duration: 1000, onComplete: () => riskText.destroy()});
        } else { newType = t1.type; }
        this.placeTowerAtCell(tr,tc,newType,newLevel); 
        const cell=this.grid[tr][tc]; 
        const fx=this.add.circle(cell.x+CELL_SIZE/2,cell.y+CELL_SIZE/2,40,0xffffff,0.8); 
        this.tweens.add({targets:fx,scale:2.5,alpha:0,duration:300, onComplete:()=>fx.destroy()});
    }
    
    returnTowerToOriginalPosition(t){ t.sprite.x=t.x; t.sprite.y=t.y; t.label.x=t.x; t.label.y=t.y+(CELL_SIZE/2)-24; } // <<< แก้ไขแล้ว!
    findTowerBySprite(s){return this.towers.find(t=>t.sprite===s);}
    destroyTower(t){
        if(t.sprite)t.sprite.destroy(); if(t.label)t.label.destroy();
        this.grid[t.r][t.c]=null;
        const i=this.towers.indexOf(t); if(i>=0)this.towers.splice(i,1);
    }
    
    spawnEnemy(){
        if(this.isGameOver)return; 
        const startPoint=this.pathPoints[0]; 
        const enemy=this.add.rectangle(startPoint.x,startPoint.y,30,36,0xff4466).setOrigin(0.5).setStrokeStyle(3, 0xffffff); // <<< แก้ไขแล้ว!
        enemy.hp=(ENEMY_BASE_HP+Math.floor(this.score*0.3))*(1+this.difficultyLevel*0.25);
        enemy.maxHp = enemy.hp;
        enemy.speed=ENEMY_BASE_SPEED+(this.difficultyLevel*12);
        enemy.isDead=false; enemy.progress=0; enemy.isMedium=false; enemy.isBoss=false;
        enemy.hpText = this.add.text(enemy.x, enemy.y - 30, `${Math.round(enemy.hp)}`, { fontSize: '16px', color: '#ffffff', fontStyle: 'bold', stroke: '#000', strokeThickness: 4, fontFamily: "'Poppins', Arial, sans-serif" }).setOrigin(0.5).setDepth(150); // <<< แก้ไขแล้ว!
        this.enemies.add(enemy); 
        this.moveEnemyAlongPath(enemy);
    }
    
    spawnMediumEnemies() {
        if (this.isGameOver || !this.boss || this.boss.isDead) return;
        for (let i = 0; i < 3; i++) {
            this.time.delayedCall(i * 500, () => {
                if (this.isGameOver) return;
                const startPoint = this.pathPoints[0];
                const mediumEnemy = this.add.rectangle(startPoint.x, startPoint.y, 40, 46, 0xff8800).setOrigin(0.5).setStrokeStyle(3, 0xffffff); // <<< แก้ไขแล้ว!
                mediumEnemy.hp = MEDIUM_ENEMY_HP + (this.difficultyLevel * 18);
                mediumEnemy.maxHp = mediumEnemy.hp;
                mediumEnemy.speed = MEDIUM_ENEMY_SPEED;
                mediumEnemy.isDead = false; mediumEnemy.progress = 0; mediumEnemy.isMedium = true; mediumEnemy.isBoss = false;
                mediumEnemy.hpText = this.add.text(mediumEnemy.x, mediumEnemy.y - 40, `${Math.round(mediumEnemy.hp)}`, { fontSize: '20px', color: '#ffffff', fontStyle: 'bold', stroke: '#000', strokeThickness: 4, fontFamily: "'Poppins', Arial, sans-serif" }).setOrigin(0.5).setDepth(150); // <<< แก้ไขแล้ว!
                this.enemies.add(mediumEnemy);
                this.moveEnemyAlongPath(mediumEnemy);
            });
        }
    }
    
    moveEnemyAlongPath(enemy){ 
        if(!enemy||enemy.isDead)return; 
        enemy.pathSegment=0; 
        this.moveEnemyToNextSegment(enemy);
    }
    
    moveEnemyToNextSegment(enemy){
        if(!enemy||enemy.isDead||enemy.pathSegment>=this.pathPoints.length-1)return;
        const nextPoint=this.pathPoints[enemy.pathSegment+1];
        const distance=this.segmentLengths[enemy.pathSegment];
        const duration=(distance/enemy.speed)*1000;
        let cumulativeDistance=0; 
        for(let i=0;i<enemy.pathSegment;i++)cumulativeDistance+=this.segmentLengths[i];
        this.tweens.add({
            targets:enemy,x:nextPoint.x,y:nextPoint.y,duration:duration,ease:'Linear',
            onUpdate:(tween)=>{
                if(!enemy||enemy.isDead)return;
                const segmentProgress=tween.progress;
                const totalProgressAtSegmentStart=cumulativeDistance/this.totalPathLength;
                const segmentWeight=distance/this.totalPathLength;
                enemy.progress=totalProgressAtSegmentStart+(segmentProgress*segmentWeight);
            },
            onComplete:()=>{
                if(!enemy||enemy.isDead)return;
                enemy.pathSegment++;
                if(enemy.pathSegment>=this.pathPoints.length-1){ this.onEnemyReachBase(enemy); }
                else{ this.moveEnemyToNextSegment(enemy); }
            }
        });
    }
    
    updateTowerAttacks(){ 
        if(this.isGameOver)return;
        const aliveEnemies=this.enemies.getChildren().filter(e=>e&&!e.isDead);
        if(aliveEnemies.length===0)return;
        const now=this.time.now; 
        for(let tower of this.towers){
            if(now-tower.lastAttack<tower.attackRate)continue;
            let bestTarget=null,bestProgress=-1;
            for(let enemy of aliveEnemies){ if(enemy.progress>bestProgress){ bestProgress=enemy.progress; bestTarget=enemy; }}
            if(bestTarget){ this.towerAttack(tower,bestTarget); tower.lastAttack=now; }
        }
    }
    
    towerAttack(tower,enemy){ 
        const projectile=this.add.circle(tower.x,tower.y,5,TOWER_CONFIG[tower.type].color); // <<< แก้ไขแล้ว!
        this.tweens.add({ targets:projectile,x:enemy.x,y:enemy.y,duration:200, onComplete:()=>projectile.destroy() }); 
        let damage=Math.round(tower.dmg*(0.9+Math.random()*0.2));
        const config=TOWER_CONFIG[tower.type];
        const specialRoll=Math.random();
        const specialChance=config.specialChance+(tower.level-1)*0.05;
        if(specialRoll<specialChance){
            if(tower.type==='arrow'){
                damage*=2;
                const critText=this.add.text(enemy.x,enemy.y,'CRIT!',{fontSize:'22px',color:'#ffdd00',fontStyle:'bold'}).setOrigin(0.5); // <<< แก้ไขแล้ว!
                this.tweens.add({targets:critText,alpha:0,y:'-=25',duration:500,onComplete:()=>critText.destroy()});
            }else{ this.applySpecialEffect(tower,enemy); }
        }
        enemy.hp-=damage; 
        this.showDamageNumber(enemy.x, enemy.y, damage, '#ffffff');
        if(enemy.hp<=0)this.killEnemy(enemy);
    }
    
    showDamageNumber(x, y, amount, color) {
        const dmgText = this.add.text(x, y, `${amount}`, { fontSize: '22px', color: color, fontStyle: 'bold', stroke: '#000', strokeThickness: 4, fontFamily: "'Poppins', Arial, sans-serif" }).setOrigin(0.5).setDepth(200); // <<< แก้ไขแล้ว!
        this.tweens.add({ targets: dmgText, y: y - 40, alpha: 0, duration: 800, ease: 'Power1.easeOut', onComplete: () => dmgText.destroy() });
    }

    castUltimate() {
        if (this.isGameOver || this.time.now - this.lastUltimateTime < ULTIMATE_COOLDOWN) return;
        this.lastUltimateTime = this.time.now;
        this.ultimateReady = false;
        this.scene.get('UIScene').showUltimateText();
        this.cameras.main.shake(200, 0.015);
        const aliveEnemies = this.enemies.getChildren().filter(e => e && !e.isDead);
        aliveEnemies.forEach(target => {
            const explosionX = target.x, explosionY = target.y;
            const explosionFx = this.add.circle(explosionX, explosionY, 8, 0xffdd00, 0.9).setDepth(180);
            this.tweens.add({ targets: explosionFx, radius: ULTIMATE_EXPLOSION_RADIUS, alpha: 0, duration: 300, ease: 'Quad.easeOut', onComplete: () => explosionFx.destroy() });
            aliveEnemies.forEach(enemyInRadius => {
                const distance = Phaser.Math.Distance.Between(explosionX, explosionY, enemyInRadius.x, enemyInRadius.y);
                if (distance < ULTIMATE_EXPLOSION_RADIUS) {
                    const damage = Math.round(ULTIMATE_EXPLOSION_DMG * (1 - (distance / ULTIMATE_EXPLOSION_RADIUS)));
                    enemyInRadius.hp -= damage;
                    this.showDamageNumber(enemyInRadius.x, enemyInRadius.y, damage, '#ffdd00');
                    if (enemyInRadius.hp <= 0) this.killEnemy(enemyInRadius);
                }
            });
            const fireZoneVisual = this.add.graphics({fillStyle: { color: 0xff6600, alpha: 0.3 }, lineStyle: { width: 3, color: 0xff0000, alpha: 0.7 } }).setDepth(5);
            fireZoneVisual.fillCircle(explosionX, explosionY, ULTIMATE_EXPLOSION_RADIUS).strokeCircle(explosionX, explosionY, ULTIMATE_EXPLOSION_RADIUS);
            const newZone = { x: explosionX, y: explosionY, radius: ULTIMATE_EXPLOSION_RADIUS, visual: fireZoneVisual, endTime: this.time.now + ULTIMATE_FIRE_ZONE_DURATION };
            this.fireZones.push(newZone);
            this.tweens.add({ targets: fireZoneVisual, alpha: 0, duration: 500, delay: ULTIMATE_FIRE_ZONE_DURATION - 500, onComplete: () => { fireZoneVisual.destroy(); this.fireZones = this.fireZones.filter(z => z !== newZone); } });
        });
        this.time.delayedCall(ULTIMATE_COOLDOWN, () => { this.ultimateReady = true; });
    }

    applySpecialEffect(tower, enemy){
        switch(tower.type){
            case 'fire': this.applyBurn(enemy, 3 + tower.level, 2000); break;
            case 'ice': this.applySlow(enemy, 0.5, 1500); break;
            case 'lightning': this.applyStrictChain(enemy, tower.dmg * 0.6, 2 + tower.level); break;
            case 'poison': this.applyPoison(enemy, 4 + tower.level, 2500); break;
        }
    }
    
    applyBurn(enemy, damagePerTick, duration){
        if(!enemy || enemy.isDead) return;
        const burnTimer = this.time.addEvent({ delay: 500, repeat: Math.floor(duration/500)-1, callback: () => {
                if(!enemy || enemy.isDead) { burnTimer.destroy(); return; }
                enemy.hp -= damagePerTick; this.showDamageNumber(enemy.x, enemy.y, damagePerTick, '#ff6a00');
                if(enemy.hp <= 0) this.killEnemy(enemy);
        }});
    }
    
    applySlow(enemy, slowFactor, duration){
        if(!enemy || enemy.isDead || enemy.isSlowed) return;
        enemy.isSlowed = true;
        this.tweens.getTweensOf(enemy).forEach(tween => { tween.timeScale = (1 - slowFactor); });
        this.time.delayedCall(duration, () => { if(enemy && !enemy.isDead) { enemy.isSlowed = false; this.tweens.getTweensOf(enemy).forEach(tween => { tween.timeScale = 1; }); } });
    }
    
    applyStrictChain(sourceEnemy, damage, maxTargets){
        if(!sourceEnemy || sourceEnemy.isDead) return;
        const sameSegmentEnemies = this.enemies.getChildren().filter(e => e && !e.isDead && e !== sourceEnemy && e.pathSegment === sourceEnemy.pathSegment && e.progress < sourceEnemy.progress).sort((a,b) => b.progress - a.progress).slice(0, maxTargets);
        let lastEnemy = sourceEnemy;
        for(let enemy of sameSegmentEnemies){
            const roundedDamage = Math.round(damage);
            enemy.hp -= roundedDamage; this.showDamageNumber(enemy.x, enemy.y, roundedDamage, '#ffff66');
            const chainLine = this.add.line(0, 0, lastEnemy.x, lastEnemy.y, enemy.x, enemy.y, 0xffff66, 0.8).setLineWidth(4, 2); // <<< แก้ไขแล้ว!
            this.tweens.add({ targets: chainLine, alpha: 0, duration: 250, onComplete: () => chainLine.destroy() });
            if(enemy.hp <= 0) this.killEnemy(enemy);
            lastEnemy = enemy;
        }
    }
    
    applyPoison(enemy, damagePerTick, duration){
        if(!enemy || enemy.isDead || enemy.isPoisoned) return;
        enemy.isPoisoned = true;
        const poisonTimer = this.time.addEvent({ delay: 500, repeat: Math.floor(duration/500)-1, callback: () => {
                if(!enemy || enemy.isDead) { poisonTimer.destroy(); return; }
                enemy.hp -= damagePerTick; this.showDamageNumber(enemy.x, enemy.y, damagePerTick, '#8fce00');
                if(enemy.hp <= 0) this.killEnemy(enemy);
            }, onComplete: () => { if(enemy && !enemy.isDead) enemy.isPoisoned = false; }
        });
    }
}

/* =========================
    SCENE: UIScene
   ========================= */
class UIScene extends Phaser.Scene {
    constructor(){ super({key: 'UIScene', active: true}); }
    create(){
        this.gameScene = this.scene.get('GameScene');
        const fontStyle = { fontFamily: "'Poppins', Arial, sans-serif", fontSize: '32px', color: '#fff', fontStyle: '700' }; // <<< แก้ไขแล้ว!
        
        this.startOverlay = this.add.rectangle(WIDTH/2, HEIGHT/2, WIDTH, HEIGHT, 0x000000, 0.7).setInteractive();
        this.startText = this.add.text(WIDTH/2, HEIGHT/2, 'TAP TO START', { ...fontStyle, fontSize: '56px' }).setOrigin(0.5); // <<< แก้ไขแล้ว!
        this.startOverlay.once('pointerdown', this.startGame, this);
        
        const summonBtnBg = this.add.graphics();
        this.summonBtn = this.add.zone(WIDTH/2-140, HEIGHT-110, 280, 80).setOrigin(0).setInteractive(); // <<< แก้ไขแล้ว!
        this.summonText = this.add.text(WIDTH/2, HEIGHT-70, `SUMMON`, fontStyle).setOrigin(0.5); // <<< แก้ไขแล้ว!
        this.summonBtn.on('pointerdown', () => this.gameScene.doSummon());
        
        this.ultimateBtnBg = this.add.graphics();
        this.ultimateCooldownIndicator = this.add.graphics();
        const ultBtnX = WIDTH - 180; // <<< แก้ไขแล้ว!
        const ultTextX = WIDTH - 110; // <<< แก้ไขแล้ว!
        this.ultimateBtn = this.add.zone(ultBtnX, HEIGHT - 110, 150, 80).setOrigin(0).setInteractive(); // <<< แก้ไขแล้ว!
        this.ultimateText = this.add.text(ultTextX, HEIGHT - 70, 'ULTIMATE', { ...fontStyle, fontSize: '24px' }).setOrigin(0.5); // <<< แก้ไขแล้ว!
        this.ultimateBtn.on('pointerdown', () => this.gameScene.castUltimate());
        
        this.hpText = this.add.text(30, 30, `HP: 0`, fontStyle).setOrigin(0,0);
        this.scoreText = this.add.text(WIDTH-30, 30, `Score: 0`, fontStyle).setOrigin(1,0);
        this.manaText = this.add.text(30, 80, `Mana: 0`, fontStyle).setOrigin(0,0);
        this.timerText = this.add.text(WIDTH/2, 30, 'Time: 30', fontStyle).setOrigin(0.5,0);
        
        this.createTowerLegend();
        
        this.skipButton = this.add.text(WIDTH - 30, 80, 'Skip Ad', { fontSize: '22px', color: '#aaa' }).setOrigin(1,0).setInteractive().setVisible(false);
        this.skipButton.on('pointerdown', () => this.showCta(this.gameScene.score));
        
        this.fpsText = this.add.text(15, HEIGHT - 50, '', { fontSize: '18px', color: '#0f0' });
        this.deltaText = this.add.text(15, HEIGHT - 30, '', { fontSize: '18px', color: '#0f0' });
        
        this.inGameUI = [summonBtnBg, this.summonBtn, this.summonText, this.manaText, this.scoreText, this.hpText, this.timerText, this.fpsText, this.deltaText, this.ultimateBtnBg, this.ultimateCooldownIndicator, this.ultimateBtn, this.ultimateText];
        
        this.ctaOverlay = this.add.rectangle(WIDTH/2,HEIGHT/2,WIDTH,HEIGHT,0x000000,0.8).setVisible(false);
        this.ctaScoreText = this.add.text(WIDTH/2,HEIGHT/2-80,'',{...fontStyle,fontSize:'48px'}).setOrigin(0.5).setVisible(false);
        this.ctaText = this.add.text(WIDTH/2,HEIGHT/2+50,'PLAY NOW!',{...fontStyle,fontSize:'84px'}).setOrigin(0.5).setVisible(false);
        this.retryButton = this.add.text(WIDTH/2, HEIGHT/2 + 180, 'Retry', {...fontStyle, fontSize: '36px', color: '#aaa'}).setOrigin(0.5).setInteractive().setVisible(false);
        this.ctaUI = [this.ctaOverlay, this.ctaScoreText, this.ctaText, this.retryButton];
        
        this.inGameUI.forEach(ui => ui.setVisible(false));
    }

    createTowerLegend() { // <<< แก้ไขแล้ว!
        const legendY = HEIGHT - 220;
        this.add.text(WIDTH/2, legendY - 40, 'TOWER TYPES', { fontSize: '22px', color: '#fff', fontStyle: 'bold', fontFamily: "'Poppins', Arial, sans-serif" }).setOrigin(0.5);
        const types = ['fire', 'ice', 'lightning', 'poison', 'arrow', 'mana'];
        const spacing = 96, startX = (WIDTH - (types.length - 1) * spacing) / 2;
        types.forEach((type, i) => {
            const x = startX + spacing * i;
            this.add.rectangle(x, legendY, 28, 22, TOWER_CONFIG[type].color).setStrokeStyle(2, 0x333333);
            const name = (type === 'lightning') ? 'BOLT' : type.toUpperCase();
            const effect = {fire:'Burn',ice:'Slow',lightning:'Chain',poison:'DoT',arrow:'Crit',mana:'Bonus'}[type];
            this.add.text(x, legendY + 22, name, {fontSize: '14px', color: '#fff', fontStyle: 'bold', fontFamily: "'Poppins', Arial, sans-serif"}).setOrigin(0.5);
            this.add.text(x, legendY + 40, effect, {fontSize: '12px', color: '#aaa', fontFamily: "'Poppins', Arial, sans-serif"}).setOrigin(0.5);
        });
    }

    startGame(){
        this.startOverlay.setVisible(false); this.startText.setVisible(false);
        this.inGameUI.forEach(ui => ui.setVisible(true));
        this.gameScene.startGame();
        this.timeLeft = 30;
        this.timerEvent = this.time.addEvent({ delay: 1000, callback: this.updateTimer, callbackScope: this, loop: true });
    }
    updateTimer(){
        if(this.timeLeft <= 0) return; this.timeLeft--; 
        this.timerText.setText(`Time: ${this.timeLeft}`);
        if ((30 - this.timeLeft) % 5 === 0 && (30 - this.timeLeft) > 0) { this.gameScene.increaseDifficulty(); }
        if (this.timeLeft <= 0) { this.timerEvent.remove(); this.timerText.setVisible(false); this.skipButton.setVisible(true); }
    }
    showUltimateText() {
        const ultText = this.add.text(WIDTH/2, HEIGHT/2, 'ULTIMATE!', { fontSize: '92px', color: '#ffdd00', fontStyle: 'bold', stroke: '#ff6600', strokeThickness: 12, fontFamily: "'Poppins', Arial, sans-serif" }).setOrigin(0.5).setDepth(300).setScale(0.5);
        this.tweens.add({ targets: ultText, scale: 1.2, alpha: 0, duration: 1500, ease: 'Cubic.easeOut', onComplete: () => ultText.destroy() });
    }
    showCta(score){
        if (this.timerEvent) this.timerEvent.remove();
        this.gameScene.freezeGame();
        this.inGameUI.forEach(ui => ui.setVisible(false));
        this.skipButton.setVisible(false); this.ctaUI.forEach(ui => ui.setVisible(true));
        this.ctaScoreText.setText(`Final Score: ${score}`);
        this.ctaOverlay.setInteractive().on('pointerdown', () => console.log("Redirecting..."));
        this.retryButton.once('pointerdown', () => { this.scene.start('GameScene'); this.scene.restart(); });
    }
    update(time, delta){
        if(this.startOverlay.visible || !this.gameScene.sys.isActive()) return;
        this.manaText.setText(`Mana: ${Math.floor(this.gameScene.mana)}`);
        this.hpText.setText(`HP: ${this.gameScene.playerHP}`);
        this.scoreText.setText(`Score: ${this.gameScene.score}`);
        
        const cost = this.gameScene.getCurrentSummonCost();
        this.summonText.setText(`SUMMON (${cost})`);
        const summonBtnBg = this.inGameUI[0];
        summonBtnBg.clear().fillStyle(this.gameScene.mana >= cost ? 0x1f8fff : 0x666666, 1).fillRoundedRect(WIDTH/2 - 140, HEIGHT - 110, 280, 80, 20); // <<< แก้ไขแล้ว!
        
        const timeSinceUltimate = this.game.getTime() - this.gameScene.lastUltimateTime;
        const ultBtnX = WIDTH - 180;
        const ultTextX = WIDTH - 105;
        if (timeSinceUltimate < ULTIMATE_COOLDOWN) {
            this.ultimateText.setText(`${Math.ceil((ULTIMATE_COOLDOWN - timeSinceUltimate) / 1000)}s`);
            this.ultimateBtnBg.clear().fillStyle(0x666666, 1).fillRoundedRect(ultBtnX, HEIGHT - 110, 150, 80, 20); // <<< แก้ไขแล้ว!
            const progress = timeSinceUltimate / ULTIMATE_COOLDOWN;
            this.ultimateCooldownIndicator.clear().lineStyle(6, 0x1f8fff, 1).beginPath().arc(ultTextX, HEIGHT - 70, 45, Phaser.Math.DegToRad(-90), Phaser.Math.DegToRad(-90 + 360 * progress), false).strokePath();
        } else {
            this.ultimateText.setText('ULTIMATE');
            this.ultimateBtnBg.clear().fillStyle(0xff4444, 1).fillRoundedRect(ultBtnX, HEIGHT - 110, 150, 80, 20); // <<< แก้ไขแล้ว!
            this.ultimateCooldownIndicator.clear();
        }

        this.fpsText.setText(`FPS: ${this.game.loop.actualFps.toFixed(1)}`);
        this.deltaText.setText(`Delta: ${delta.toFixed(2)}ms`);
    }
}
/* =========================
    GAME CONFIG
   ========================= */
const config = {
    type: Phaser.AUTO,
    width: WIDTH,
    height: HEIGHT,
    parent: 'game',
    backgroundColor: '#000011',
    
    // <<< แก้ไขแล้ว! การตั้งค่าเพื่อความคมชัดสูงสุด
    render: {
        antialias: true,
        pixelArt: false, // ใช้ false เพื่อให้ภาพสมูท ไม่เป็น pixel art
        roundPixels: true
    },
    resolution: window.devicePixelRatio || 1, // ใช้ค่า resolution ของจอจริง
    
    physics: {
        default: 'arcade',
        arcade: { debug: false }
    },
    scene: [GameScene, UIScene],
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    }
};
const game = new Phaser.Game(config);
</script>
</body>
</html>